<HTML>
<HEAD>
<TITLE>Chapter 10 -- Implementing Web Chat</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;10</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Implementing Web Chat</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#LetsTalk">
Let's Talk</A>
<LI><A HREF="#ScriptBasedChat">
Script-Based Chat</A>
<UL>
<LI><A HREF="#TheFrontDoor">
The Front Door</A>
<LI><A HREF="#EnteringDialog">
Entering Dialog</A>
<LI><A HREF="#TheChatWindow">
The Chat Window</A>
</UL>
<LI><A HREF="#EnhancementsandExtensions">
Enhancements and Extensions</A>
<UL>
<LI><A HREF="#AquotWhoquotOption">
A &quot;Who&quot; Option</A>
<LI><A HREF="#MultipleChatRooms">
Multiple Chat Rooms</A>
<LI><A HREF="#PrivateChat">
Private Chat</A>
</UL>
<LI><A HREF="#SummaryofWebChat">
Summary of Web Chat</A>
<LI><A HREF="#FromHere">
From Here&#133;</A>
</UL>

<HR>
<P>
Everybody's talking about it: the ability to utilize the Web to
communicate with one another-in real time. Initially, this was
limited to IRC (<I>Internet Relay Chat</I>), a protocol such as
FTP, or Telnet where you'd assume an alter ego by defining an
<I>alias</I> or fake name, and then enter a <I>channel, </I>which
is the electronic equivalent of a room where several people would
talk, much analogous to the CB radio days.
<H2><A NAME="LetsTalk"><FONT SIZE=5 COLOR=#FF0000>
Let's Talk</FONT></A></H2>
<P>
The Web has brought a new dimension to online chat-the concept
of a &quot;chat room,&quot; which takes the straight-text environment
of IRC and gives it a visual, virtual world in which to communicate.
<P>
There are several methods of implementing Web chat:
<BLOCKQUOTE>
Using a custom browser plug-in to handle the chat interface (such
as IChat).<BR>
Using Java to create a &quot;chat applet.&quot;<BR>
Using forms and CGI to process the ongoing conversation.
</BLOCKQUOTE>
<P>
Whichever method you prefer, they all rely on the capability of
the user's browser to transmit information back to the server.
It is then added to the conversation at large and sent back to
the user.
<P>
Remember, on the Web, browsers themselves are not interconnected.
Each surfer is communicating between oneself and the server. Even
if several people are browsing pages from the same server, they
are not aware of each other's existence.
<H2><A NAME="ScriptBasedChat"><FONT SIZE=5 COLOR=#FF0000>
Script-Based Chat</FONT></A></H2>
<P>
One easy method to implement scripted chat is to utilize frames
to create &quot;inbound&quot; and &quot;outbound&quot; sections
of the browser. In other words, you create a chat environment
that consists of two frames:
<OL>
<LI>Top frame-this displays the ongoing conversation.
<LI>Bottom frame-this contains a form that the user utilizes to
enter the dialog.
</OL>
<P>
One nice example of this is CyberIsland by LinkScape (<B><A HREF="http://www.pageturners.com/linkscape/">http://www.pageturners.com/linkscape/</A></B>),
where the basic chat principles are &quot;gussied up&quot; with
some good graphics as well (see fig. 10.1).
<P>
<A HREF="f10-1.gif"><B>Figure 10.1 :</B> <I>Generally, Web chat systems are not heavily
graphic because they are constantly loading data from the server.
However, some judicious backgrounds and lines can make for a pleasing
layout</I>.</A>
<P>
Listing 10.1 demonstrates the basic <TT>&lt;FRAMESET&gt;</TT>
that sets up everything. As you can see, it's a standard frame
construction, with the source documents for each frame being the
CGI scripts that drive each section.
<HR>
<BLOCKQUOTE>
<B>Listing 10.1&nbsp;&nbsp;Framed Chat<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Web Chat&lt;/TITLE&gt;
&lt;/HEAD&gt;

&lt;FRAMESET ROWS=&quot;*,200&quot;&gt;
   &lt;FRAME NAME=&quot;messages&quot; SRC=&quot;/cgi-bin/readchat.cgi&quot;&gt;
   &lt;FRAME NAME=&quot;submit&quot; SRC=&quot;/cgi-bin/writechat.cgi&quot;&gt;
&lt;/FRAMESET&gt;
&lt;/HTML&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Before you actually start setting up the frames and firing chat
documents back and forth, you need to get some information from
the user. This is handled by the &quot;front door&quot; to your
chat system.
<H3><A NAME="TheFrontDoor">
The Front Door</A></H3>
<P>
Prior to letting someone into your chat room, you need to know
something about them, to identify from whom a comment is coming,
if nothing else. Most chat systems deal with this through a front
door form like the one in listing 10.2. This form gets all the
necessary information and then fires up the chat script.
<HR>
<BLOCKQUOTE>
<B>Listing 10.2&nbsp;&nbsp;The Front Door<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Chat Page&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Welcome To The Chat Page&lt;/H1&gt;
&lt;FORM METHOD=POST ACTION=chat.cgi&gt;
&lt;HR&gt;
&lt;STRONG&gt;Enter Information Below:&lt;/STRONG&gt;&lt;p&gt;

&lt;TABLE BORDER=1&gt;
&lt;TR&gt;
&lt;TD ALIGHT=RIGHT&gt;User Name:&lt;/TD&gt;
&lt;TD&gt;&lt;INPUT NAME=chat_username&gt;&lt;/TD&gt;
&lt;/TR&gt;
&lt;TR&gt;
&lt;TD ALIGHT=RIGHT&gt;Your Email Address(*):&lt;/TD&gt;
&lt;TD&gt;&lt;INPUT NAME=chat_email&gt;&lt;/TD&gt;
&lt;/TR&gt;
&lt;TR&gt;
&lt;TD ALIGHT=RIGHT&gt;Your Home Page (*):&lt;/TD&gt;
&lt;TD&gt;&lt;INPUT NAME=chat_http&gt;&lt;/TD&gt;
&lt;/TR&gt;
&lt;/TABLE&gt;
&lt;P&gt;
&lt;INPUT TYPE=SUBMIT NAME=enter_chat
VALUE=&quot;Enter The Chat Room&quot;&gt;

&lt;HR&gt; 
&lt;/FORM&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="EnteringDialog">
Entering Dialog</A></H3>
<P>
The user enters dialog through a form and presses the Submit button.
The data is then passed off to a Perl script that processes the
information and constructs a new HTML page that displays in the
user's top frame:
<BLOCKQUOTE>
<PRE>
&lt;HTML&gt;
&lt;FORM METHOD=POST ACTION=&quot;/cgi-bin/writechat.cgi&quot; TARGET=&quot;messages&quot;&gt;
&lt;INPUT TYPE=TEXT NAME=&quot;dialog&quot; SIZE=40&gt;
&lt;/FORM&gt;
&lt;/HTML&gt;
</PRE>
</BLOCKQUOTE>
<P>
The CGI script that is fired when this form is submitted (see
listing 10.3) is relatively simple, and uses the same principles
as other scripting tricks such as a graffiti wall. In a nutshell:
<OL>
<LI>Parse the input data.
<LI>Grab the current dialog database.
<LI>Write out the user's comment to the dialog database.
<LI>Grab the current dialog page (HTML).
<LI>Write a new dialog page.
</OL>
<HR>
<BLOCKQUOTE>
<B>Listing 10.3&nbsp;&nbsp;Writing Out New Chat<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
if ($submit_message ne &quot;&quot;) {
    if ($chat_to_user eq &quot;&quot; ||
        $chat_to_user =~ /^all$/i ||
        $chat_to_user =~ /everyone/i) {
        $chat_to_user  = &quot;ALL&quot;;
    }
  
    $high_number = &amp;GetHighMessageNumber;
    $high_number++; 
    $high_number = sprintf(&quot;%6d&quot;,$high_number);
    $high_number =~ tr/ /0/;           
    open(MSGFILE, &quot;&gt;$chat_room_dir/$high_number.msg&quot;);
    print MSGFILE &quot;$user_name\n&quot;;
    print MSGFILE &quot;$user_email\n&quot;;
    print MSGFILE &quot;$user_http\n&quot;;
    print MSGFILE &quot;$chat_to_user\n&quot;;
    print MSGFILE &quot;$current_date_time\n&quot;;
    print MSGFILE &quot;$chat_message\n&quot;;
    close(MSGFILE);

    &amp;PruneOldMessages($chat_room_dir);

    $old_last_read = $user_last_read;
    ($user_name, $user_email, $user_http,
     $refresh_rate, $how_many_old, 
     $user_last_read, $high_message) = 
      &amp;GetSessionInfo($session, $fsubmit, $frames);
    $user_last_read = $old_last_read;
}

...
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The only major decision is whether to place the new dialog at
the top or bottom of the file. IRC users are familiar with how
new dialog always appears at the bottom of the chat window, with
the conversation getting &quot;older&quot; as the window scrolls
up. Web pages, however, are always loaded with new dialog from
the top with conversations getting older as you scroll <I>down</I>
the screen naturally.
<H3><A NAME="TheChatWindow">
The Chat Window</A></H3>
<P>
The top frame simply requests the chat page for display. To force
the page to reload every 30 seconds, without having the user's
entire screen reformat every time, the client-pull technique is
used:
<BLOCKQUOTE>
<PRE>
&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;30&quot; URL=&quot;/cgi-bin/readchat.cgi&quot;&gt;
</PRE>
</BLOCKQUOTE>
<P>
By having it reload from the script, you force the script to generate
the latest amount of chat dialog with each pull. The script that
prepares the page (listing 10.4) is straight-forward: Open the
file and write it out.
<HR>
<BLOCKQUOTE>
<B>Listing 10.4&nbsp;&nbsp;Updating the Chat Window<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
print &quot;Content-type:  text/html\n&quot;;
print &quot;Pragma: no-cache\n\n&quot;;

print &quot;&lt;HTML&gt;&lt;HEAD&gt;&quot;;
print qq!&lt;META HTTP-EQUIV=&quot;Refresh&quot; ! .
      qq!CONTENT=&quot;$refresh_rate; ! .
      qq!URL=/cgi-bin/readchat.cgi&gt;!;
print &quot;&lt;/HEAD&gt;&lt;BODY&gt;&quot;;

open (CHAT, &quot;$chatFile&quot;);

while(&lt;CHAT&gt;) {
   print @_,&quot;&lt;BR&gt;&quot;;
close(CHAT);

print &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;;
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
When performing a Web activity that constantly pulls pages, remember browsers cache pages to speed up access to places frequently surfed. With a chat script, you are &quot;reloading&quot; the page in the top frame at a regular interval; however, the URL of 

the document is not changing. If you let the browser cache the page locally, the local copy will be the one pulled with each refresh.</BLOCKQUOTE>
<BLOCKQUOTE>
An easy way around this is to modify the standard content header that your script prints at the top of the page to force the browser <I>not</I> to cache the page:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>Content-type: text/html\n</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>Pragma: no-cache\n\n</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
When the browser encounters the &quot;no-cache&quot; directive, it won't cache a local copy of the page in memory or on disk.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="EnhancementsandExtensions"><FONT SIZE=5 COLOR=#FF0000>
Enhancements and Extensions</FONT></A></H2>
<P>
So far, the Web chat system has been fairly simple. In addition,
there are several obvious ways to extend the system, including:
<UL>
<LI>Allowing a &quot;chatter&quot; to query for information about
a fellow &quot;chatter.&quot;
<LI>Support for multiple chat rooms.
<LI>Allowing for private chats between two or more people, where
others aren't allowed into the room once a privacy flag has been
set.
</UL>
<P>
As with all the other scripts and tricks discussed in this book,
the implementations of these extensions can all be found on the
companion CD-ROM in the Source Code section under chapter 9, &quot;Bulletin
Boards.&quot;
<H3><A NAME="AquotWhoquotOption">
A &quot;Who&quot; Option</A></H3>
<P>
Some people are nosy, and want to know more about who they're
talking to. For those who &quot;need to know,&quot; you can provide
an additional option that lists all the information you collect
from your visitors as they enter chat.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>TIP</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
If you want to implement this option, you might want to consider offering your visitors the opportunity to decline to divulge information as well, to satisfy the extremely paranoid or the highly secretive.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="MultipleChatRooms">
Multiple Chat Rooms</A></H3>
<P>
With only one &quot;chat room&quot; you are either limited to
one topic or doomed to mass confusion, as everyone talks about
something different. The basic chat structure is adaptable to
handle multiple chat rooms by:
<UL>
<LI>Creating a different subdirectory in the database path for
each chat room. Each room then has its own place to store the
necessary database files.
<LI>Adding one additional parameter to both the doorway form and
the chat form-the name (or ID) of the chat room the user is &quot;in.&quot;
</UL>
<H3><A NAME="PrivateChat">
Private Chat</A></H3>
<P>
Even in public places, such as the Web, people sometimes desire
the &quot;privacy&quot; of a &quot;secure&quot; chat. If you think
about this, it's not too difficult to set up if you follow these
steps:
<OL>
<LI>Add another option to the lower-frame chat form to &quot;lock&quot;
the current chat room. This prevents additional people from entering.
<LI>Write the lock information out as a flag on the chat files.
<LI>When constructing the chat front door, look for the presence
of this flag on a chat room. If it is present, do not consider
that particular chat room an option.
</OL>
<P>
Remember to &quot;clean up the room&quot; after everyone leaves;
that is, delete the conversation files, remove the privacy flag,
and make the room available for open chat again. For a complete,
running, and private chat example, be sure to check out the companion
CD-ROM.
<H2><A NAME="SummaryofWebChat"><FONT SIZE=5 COLOR=#FF0000>
Summary of Web Chat</FONT></A></H2>
<P>
While implementing a real-time chat room entirely with scripting
is probably not too practical, the reload times can become a problem,
especially when chatters have the tendency to be rather verbose.
It's an interesting experiment in using scripting to get several
people to communicate through the Web.
<P>
Possible extensions to this technique are:
<BLOCKQUOTE>
A periodically updated calendar or alarm clock in which company
meetings can be flagged to remind the user.
</BLOCKQUOTE>
<BLOCKQUOTE>
A customized advertising system where different information, tailored
to the user's tastes, is loaded periodically-based on the information
the user fills out in the form.
</BLOCKQUOTE>
<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>
From Here&#133;</FONT></A></H2>
<P>
For more information on this and other related techniques, check
out:
<UL>
<LI><A HREF="ch8.htm" >Chapter 8</A> &quot;Advertising with Billboards,&quot; explains
generating graphic billboards from the server and using client-side
scripting to display billboards.
<LI><A HREF="ch9.htm" >Chapter 9</A> &quot;Bulletin Boards,&quot; discusses Web-based
bulletin boards.
<LI><A HREF="ch12.htm" >Chapter 12</A>, &quot;Guestbook/Graffiti Wall,&quot; shows you
how to create a guestbook and a graffiti wall, where visitors
can leave messages for others.
</UL>
<HR>

<CENTER><P><A HREF="ch9.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch11.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
