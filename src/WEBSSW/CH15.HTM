<HTML>
<HEAD>
<TITLE>Chapter 15 -- Managing a Database</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;15</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Managing a Database</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#ServerSideDatabases">
Server-Side Databases</A>
<LI><A HREF="#ClientSideDatabases">
Client-Side Databases</A>
<UL>
<LI><A HREF="#AFormBasedDatabase">
A Form-Based Database</A>
<LI><A HREF="#LoadingtheDatabase">
Loading the Database</A>
<LI><A HREF="#GenericUserObjects">
Generic User Objects</A>
</UL>
<LI><A HREF="#FromHere">
From Here&#133;</A>
</UL>

<HR>
<P>
Of the various Web site add-ons discussed within the chapters
of this book, many rely on the ability to store, access, and modify
information that remains in a central repository on the server-a
database. Whether you're dealing with customer orders, address
lists, advertiser indexes, or a collection of your favorite Cajun
recipes, you're going to need to understand how to create and
manipulate databases.
<H2><A NAME="ServerSideDatabases"><FONT SIZE=5 COLOR=#FF0000>
Server-Side Databases</FONT></A></H2>
<P>
The simplest database structure is that of a &quot;flat file,&quot;
which is nothing more than a plain ASCII (text) file. The trick
with flat file databases is in defining how the individual fields
and records are identified. For flat files, this is commonly done
by:
<BLOCKQUOTE>
Declaring each record to occupy one physical line of the file.
This means the &quot;newline&quot; character serves as the delimiter
between records.
</BLOCKQUOTE>
<BLOCKQUOTE>
Defining a character to serve as a &quot;field delimiter&quot;
to separate individual fields within a record. The field delimiter
must be a character that doesn't exist within the actual data
elements themselves.
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><BLOCKQUOTE>
<B>TIP</B>
</BLOCKQUOTE>
</TD>
</TR>
<TR><TD><BLOCKQUOTE>
For several excellent examples complete with source code of server-side (Perl-based) databases, stop by &quot;Matt's Script Archive&quot; at <B><A HREF="http://www.worldwidemart.com/scripts/">http://www.worldwidemart.com/scripts/</A></B> or &quot;Selena 
Sol's Public Domain CGI Script Archive and Resource Library&quot; at <B>http://www.eff.org/~erict/Scripts/</B>. Both sites also have many links to <I>other</I> sites that implement the various scripts in different ways.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
For example, assuming that the <TT>|</TT> character is used as
a delimiter, a sample database would look something like:
<BLOCKQUOTE>
<PRE>
Record1Field1|Record1Field2|...|Record1FieldM
Record2Field1|Record2Field2|...|Record2FieldM
...
RecordNField1|RecordNField2|...|RecordNFieldM
</PRE>
</BLOCKQUOTE>
<P>
This assumes that each record within the database will have <TT>M</TT>
fields. In the event that a particular field doesn't exist for
a record, meaning that field would be <I>empty</I>, it still must
exist within the database structure as two delimiters with nothing
between them, as in:
<BLOCKQUOTE>
<PRE>
Field1||Field3
</PRE>
</BLOCKQUOTE>
<P>
which indicates that <I>Field2</I> is empty.
<P>
To load a flat file database into Perl for processing, you parse
it just like any other input file and store the field information
in a collection of lists. A Perl fragment that demonstrates how
to load such a database into three Perl arrays is shown in listing
15.1.
<HR>
<BLOCKQUOTE>
<B>Listing 15.1&nbsp;&nbsp;Parsing the Database<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
open (DATABASE, 'databasefile');

while (&lt;DATABASE&gt;) {
   ($field1, $field2, field3) = split (/\|/, $_);
   chop $field3;
   push (@list1, $field1);
   push (@list2, $field2);
   push (@list3, $field3);
}

close (DATABASE);
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>chop</TT> statement cuts off the tail end of the last
field, eliminating the newline character (<TT>\n</TT>) that Perl
treats as part of the input stream. This is because it's actually
stored within the file. 
<P>
Once the <TT>while</TT> loop finishes, the internal lists hold
all the data from the database. At that point, accessing a particular
record is done by indexing the respective fields.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>TIP</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Remember, Perl can look at file handles much the same way it looks at Boolean values. The statement:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>while (&lt;DATABASE&gt;)</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
is the same as saying, &quot;while &lt;DATABASE&gt; isn't empty or at the end of the file.&quot;</BLOCKQUOTE>
<BLOCKQUOTE>
This trick isn't limited to <TT>while</TT> loops. Any Perl statement that requires a Boolean check of a file handle can use it. For example:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>if (&lt;DATABASE&gt;) {</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>   # There's something to process</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>} else {</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>   # Either the file's empty, not opened, or</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>   # the pointer is at the end of the file</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>}</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="ClientSideDatabases"><FONT SIZE=5 COLOR=#FF0000>
Client-Side Databases</FONT></A></H2>
<P>
Depending on the size of your database, it may be more practical
to incorporate it directly into the HTML documents through a form.
This brings the data to the user's local drive and greatly speeds
up any accessing/processing that is performed.
<P>
There are several things to remember when planning a client-side
database:
<OL>
<LI>This trick is limited to browsers that support client scripting.
Depending on your target audience, this may not be a practical
method. It would not be a good method, for example, if the bulk
of your visitors surf with Mosaic or Lynx.
<LI>Unless you submit the form containing the database to a server-side
application, any changes made to its data will exist only for
as long as the user has your page(s) loaded.
<LI>The database itself must be relatively small. The actual size
depends on the kind and quantity of the data. Remember that the
entire database transfers from the server to the user's browser
when your page loads.
</OL>
<P>
While these may seem to limit the usefulness of a client-side
database, there are many valid applications, such as:
<BLOCKQUOTE>
Lists of favorite links for creating a customized &quot;go to&quot;
form.
</BLOCKQUOTE>
<BLOCKQUOTE>
<I>Small</I> product catalogs with only a handful of items.
</BLOCKQUOTE>
<BLOCKQUOTE>
Advertiser information to dynamically change ads on your page.
By having the database local, the browser doesn't have to reload
new graphics from the server.
</BLOCKQUOTE>
<P>
In other words, whenever you wish to work quickly from the browser's
point of view with a collection of data, it may be worthwhile
to construct a client-side database and let the browser do the
bulk of the data crunching.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>TIP</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
An excellent source of scripts and examples that demonstrate client-side databases is &quot;Cut-N-Paste JavaScript&quot; at <B><A HREF="http://www.infohiway.com/javascript/">http://www.infohiway.com/javascript/</A></B>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="AFormBasedDatabase">
A Form-Based Database</A></H3>
<P>
The <TT>hidden</TT> object of an HTML form is a powerful little
field. With it, you can pass information to a server-side program,
such as predefined values for a script, or you can store a large
quantity of data as a pseudo-database for manipulation within
the client. Because <TT>hidden</TT> fields never display to the
user, they make great &quot;pigeon holes,&quot; i.e., small storage
spaces, for databases.
<P>
As far as the structure goes, the data stored within a form's
<TT>hidden</TT> field can be in the same format as that stored
within a server-side flat-file, with one little addition-the definition
of a second delimiter to identify the end of a data record. For
example, a server's database might look like:
<BLOCKQUOTE>
<PRE>
R1F1|R1F2|...|R1FM
R2F1|R2F2|...|R2FM
</PRE>
</BLOCKQUOTE>
<P>
If you use the asterisk (<TT>*</TT>) as a record delimiter, the
structure would look like:
<BLOCKQUOTE>
<PRE>
R1F1|R1F2|...|R1FM*R2F1|R2F2|...|R2FM
</PRE>
</BLOCKQUOTE>
<P>
that could then be stored in a form within a <TT>hidden</TT> field
as the field's <TT>VALUE</TT> attribute, as shown in listing 15.2.
For example, if you wanted to create a database of your favorite
URLs, you would create something like this:
<BLOCKQUOTE>
<PRE>
Vector|www.visi.com*LANscape|www.lanscape.com*Mello Smello|www.mellosmello.com
</PRE>
</BLOCKQUOTE>
<P>
This specifies a database of three records, each record having
two fields: one being the name of the site and the second its
URL.
<HR>
<BLOCKQUOTE>
<B>Listing 15.2&nbsp;&nbsp;A Form-Based Database<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;FORM ...&gt;
   &lt;INPUT TYPE=HIDDEN NAME=&quot;DB&quot; 
          VALUE=&quot;R1F1|R1F2|...|R1FM*R2F1|R2F2|...|R2FM&quot;&gt;
&lt;/FORM&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="LoadingtheDatabase">
Loading the Database</A></H3>
<P>
Once the data has been defined within the form, it still needs
to be in a format that can be managed. This is a job best left
to JavaScript, which can easily convert the field's data into
an internal array. This process happens in two phases:
<OL>
<LI>The form field divides into individual records.
<LI>The records divide into fields.
</OL>
<P>
Both phases perform the same operation-they search through the
field data looking for delimiters. The only difference lies in
<I>which</I> delimiter is being looked for-a record or a field
delimiter.
<P>
To divide the field data into records, a code fragment similar
to that shown in listing 15.3 is used.
<HR>
<BLOCKQUOTE>
<B>Listing 15.3&nbsp;&nbsp;Creating Records from a Form Field
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
strDB  = new MakeArray();
formDB = Forms[0].DB.value;
index  = 0;

while(true) {
   var pos = formDB.indexOf(&quot;*&quot;);

   if(pos == -1) {
      // no more records
      if(formDB.length) {
         strDB[index] = formDB;
      }

      break;
   }

   strDB[index++] = formDB.substring(0, pos);

   formDB = formDB.substring(pos + 1, formDB.length);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>indexOf()</TT> method returns the first occurrence of
the given string. In this case, it is the record delimiter. If
a delimiter can't be found, and the end of the database string
has been reached, the code checks to see if there's a delimiter
after the last record.
<P>
If a delimiter is found, its position is used by the <TT>substring()</TT>
method to pull the characters from the beginning of the string
up to, but not including, the delimiter and store this new substring
in the next index in the database array. Once stored, <TT>substring()</TT>
is used again, this time to retrieve the rest of the database,
starting <I>after</I> the delimiter and continuing to the end
of the database string. This new substring becomes the new database
string and the process continues.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
JavaScript arrays are <I>dynamically sizable</I>-you can make them larger simply by referencing an index outside the array's previous dimensions.
</BLOCKQUOTE>
<BLOCKQUOTE>
There are limits to this, though. While you can make an array larger, you cannot make it smaller.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
With the field data divided into individual records, breaking
it into fields is done much the same way. The only difference
is that each database record has more than one field, so an array
of <I>user-defined </I>objects is needed to store each record.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
User-defined objects were first introduced back in chapter 8, &quot;Advertising with Billboards.&quot;</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Start with defining the object's properties (listing 15.4), and
then use a <TT>while</TT> loop similar to that in listing 15.3
to load the database.
<HR>
<BLOCKQUOTE>
<B>Listing 15.4&nbsp;&nbsp;Defining a User Object<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
function UserObject(strField1, strField2) {
   this.Field1 = strField1;
   this.Field2 = strField2;
   return this;
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="GenericUserObjects">
Generic User Objects</A></H3>
<P>
An interesting, and more flexible, alternative to having to create
custom object definition functions each time you create a new
object type is to take advantage of the JavaScript <TT>eval()</TT>
method. The <TT>eval()</TT> method takes one parameter, a string,
and tries to interpret it as a JavaScript statement. Because the
parameter is a string, you can build a statement dynamically within
JavaScript, such as:
<BLOCKQUOTE>
<PRE>
eval(&quot;this.&quot; + strFieldName + &quot; = strFieldValue&quot;);
</PRE>
</BLOCKQUOTE>
<P>
If <TT>strFieldName</TT> contained <TT>Name</TT>, it would be
interpreted by JavaScript as:
<BLOCKQUOTE>
<PRE>
this.Name = strFieldValue;
</PRE>
</BLOCKQUOTE>
<P>
where <TT>strFieldValue</TT> is a variable in itself, containing
the value to store in the field.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The property name, indicated by <TT>strFieldName,</TT> needs to be outside of quotation marks so that it can be processed properly by the JavaScript string handler. The variable name for the field's value, however, needs to be <I>within</I> quotation 
marks, so it doesn't get evaluated until the entire string is handed off to JavaScript for interpretation.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Different types of objects will probably have different numbers
of fields, so there needs to be a way to handle a variable number
of parameters within the object creation function. JavaScript
provides the <TT>arguments</TT> property to allow this. Every
function you create in JavaScript has an <TT>arguments</TT> property,
an array of the parameters that are passed to the function. As
with other JavaScript arrays, <TT>arguments</TT> has a <TT>length</TT>
property (the number of parameters) and is indexed to get the
value of each parameter.
<P>
The code shown in listing 15.5 uses <TT>arguments</TT> and <TT>eval()</TT>
to extend the ability of the object creation function to handle
objects of different types.
<HR>
<BLOCKQUOTE>
<B>Listing 15.5&nbsp;&nbsp;Variable-Type Object Creation<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
function UserObject() {
   argc = UserObject.arguments.length;
   argv = UserObject.arguments;

   for(var i=0; i&lt;argc; i+=2) {
      var strNewValue = argv[i+1];
      var strNewField = &quot;this.&quot; + argv[i] 
                      + &quot; = strNewValue;&quot;;

      eval(strNewField);
   }

   return this;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Parameters are passed to the <TT>UserObject()</TT> method in pairs:
the name of the property and the value it contains. The <TT>Billboard()</TT>
object from chapter 8, for example, could be rewritten using the
<TT>UserObject()</TT> function like this:
<BLOCKQUOTE>
<PRE>
function Billboard(strImageURL, strLinkURL) {
   return UserObject(&quot;imageURL&quot;, strImageURL,
                     &quot;linkURL&quot;, strLinkURL);
}
</PRE>
</BLOCKQUOTE>
<P>
At first glance, this trick may not appear to be useful. Suppose
your database is modified so that it contains field names as well
as field data. You could then load the information, including
specific property names. You can then use them within a customized
search form that modifies its behavior based on the fields in
the database.
<P>
A real-world example of this little trick is shown in chapter
18, &quot;Online Store Product Searches.&quot;
<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>
From Here&#133;</FONT></A></H2>
<P>
This chapter introduces several tricks for manipulating databases
from the server (through Perl) and the browser (through JavaScript).
Many of these methods are the basis for techniques used by other
chapters in this book. To see examples of these tricks in action,
check out:
<UL>
<LI><A HREF="ch8.htm" >Chapter 8</A> &quot;Advertising with Billboards,&quot; for an
example of using a database to create an advertising billboard.
<LI><A HREF="ch9.htm" >Chapter 9</A> &quot;Bulletin Boards,&quot; which demonstrates
how to create a Web-based message forum.
<LI><A HREF="ch17.htm" >Chapter 17</A>, &quot;Creating Online Catalogs,&quot; where databases
are used to store both products and the user's purchases.
<LI><A HREF="ch18.htm" >Chapter 18</A>, &quot;Online Store Product Searches,&quot; where
you see how to search a database of product information.
</UL>
<HR>

<CENTER><P><A HREF="ch14.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch16.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
