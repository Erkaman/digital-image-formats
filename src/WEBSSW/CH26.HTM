<HTML>
<HEAD>
<TITLE>Chapter 26 -- Online Testing</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;26</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Online Testing</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#DocumentLayout">
Document Layout</A>
<LI><A HREF="#TheQuestionBase">
The Question Base</A>
<LI><A HREF="#DisplayingaQuestion">
Displaying a Question</A>
<LI><A HREF="#HandlingtheAnswer">
Handling the Answer</A>
<LI><A HREF="#AddingItAllUp">
Adding It All Up</A>
<LI><A HREF="#FromHere">
From Here&#133;</A>
</UL>

<HR>
<P>
If your site is designed to teach-and more and more sites are
appearing that are, you may want to offer online testing for whatever
material you present, such as home schooling, and so on.
<H2><A NAME="DocumentLayout"><FONT SIZE=5 COLOR=#FF0000>
Document Layout</FONT></A></H2>
<P>
To keep the JavaScript code and database in the browser from page
to page, it's necessary to design the testing engine with frames,
placing your JavaScript code in the parent frame, and the control
code in one of the child frames.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>Persistent JavaScript Across Documents</B>
</TD></TR>
<TR><TD>
<BLOCKQUOTE>
Even if you don't plan on using frames, you need to if you're designing a pageset that requires JavaScript variables to keep their values as you move from page to page. Netscape Navigator 3.0 handles the <TT>write()</TT> method of the document object a 
little differently than its predecessor (or Internet Explorer, for that matter). When using <TT>document.write()</TT> to send the entire contents of a document (from <TT>&lt;HTML&gt;</TT> to <TT>&lt;/HTML&gt;</TT>) to a window, <I>all </I>of the previous 
window content is destroyed. This includes any JavaScript code that the document being replaced may have contained. In other words, If you had a document with JavaScript code that wrote out a new document into the same window, the code would delete itself 

<I>before</I> the new document data was processed. If the code were to call other JavaScript functions within the document, <I>and</I> make these calls after an initial <TT>document.write()</TT>, the browser would present you with an alert box saying that 

the function in question isn't defined-Navigator having deleted it from memory.
</BLOCKQUOTE>
<BLOCKQUOTE>
There are two ways around this anomaly:</BLOCKQUOTE>
<OL>
<LI>Have the <TT>document.write()</TT> statements write out the JavaScript code, as well as the regular HTML.
<LI>Use frames, keeping the code persistent in a frame that never gets overwritten.
</OL>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Listing 26.1 shows the frame layout used here, which looks like
what's displayed in figure 26.1, consisting of the following:
<P>
<A HREF="f26-1.gif"><B>Figure 26.1 :</B> <I>The top and middle frames are actually
dynamically generated html documents. All the work is done by
the bottom frame</I>.</A>
<UL>
<LI>A <TT>banner</TT> frame, which displays a dynamically changing
&quot;Question <I>x</I>&quot; title.
<LI>A <TT>body</TT> frame, which displays the question and answers.
<LI>A <TT>nav</TT> frame, which serves as the answer engine, the
navigator.
</UL>
<HR>
<BLOCKQUOTE>
<B>Listing 26.1&nbsp;&nbsp;Basic Quiz Frame Structure<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;FRAMESET ROWS=&quot;42,*,38&quot;&gt;
   &lt;FRAME NAME=&quot;banner&quot; SRC=&quot;title.htm&quot; NORESIZE SCROLLING=NO
          MARGINHEIGHT=0&gt;
   &lt;FRAME NAME=&quot;body&quot; SRC=&quot;cover.htm&quot;&gt;
   &lt;FRAME NAME=&quot;nav&quot; SRC=&quot;nav1.htm&quot; NORESIZE SCROLLING=NO
          MARGINHEIGHT=2&gt;
&lt;/FRAMESET&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<P>
As you learned in chapter 17, &quot;Creating Online Catalogs,&quot;
even though you have two frames that will display dynamic HTML
documents, you still need to initialize them within the <TT>&lt;FRAMESET&gt;</TT>
tag with &quot;dummy&quot; or placeholder files. If you don't,
the frame is created, but not completed (from a JavaScript standpoint),
meaning you can't access it to change its contents. This isn't
really a problem, as it gives you a good reason to create a home
page structure for your quiz, welcoming the user to the test.
<H2><A NAME="TheQuestionBase"><FONT SIZE=5 COLOR=#FF0000>
The Question Base</FONT></A></H2>
<P>
<A HREF="ch15.htm" >Chapter 15</A>, &quot;Managing a Database,&quot; introduced the basis
of database manipulation with JavaScript, and those same principles
apply here. Listing 26.2 shows the database format chosen, which
contains the following:
<UL>
<LI>The question
<LI>Four possible answers
<LI>The correct answer
</UL>
<HR>
<BLOCKQUOTE>
<B>Listing 26.2&nbsp;&nbsp;Question Database<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
Questions    = new initArray(3);
Questions[1] = new Question(&quot;What year was Windows 95 released?&quot;, 
                            &quot;1994&quot;, &quot;1985&quot;, &quot;2095&quot;, &quot;1995&quot;, &quot;4&quot;);
Questions[2] = new Question(&quot;What was the first computer?&quot;, 
                            &quot;Altair&quot;, &quot;IBM-PC&quot;, &quot;Macintosh&quot;, &quot;TRS-80&quot;, &quot;1&quot;);
Questions[3] = new Question(&quot;Which of the following is &lt;B&gt;not&lt;/B&gt; a browser:&quot;, 
                            &quot;Internet Explorer&quot;, 
                            &quot;Navigator&quot;, 
                            &quot;WebThing&quot;, 
                            &quot;Pioneer&quot;, &quot;3&quot;);

function initArray(iSize) {
   this.length = iSize;

   for(var i=1; i&lt;=iSize; i++)
      this[i] = null;

   return this;
}

function Question(strQ, strA, strB, strC, strD, strCorrect) {
   this.question     = strQ;
   this.ans1         = strA;
   this.ans2         = strB;
   this.ans3         = strC;
   this.ans4         = strD;
   this.correct      = strCorrect;

   return this;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
You may have spotted the third question, which has HTML embedded within its body (the <TT>&lt;B&gt;</TT> tag bolds the word <I>not</I>). Because the question is treated as a string that is processed just like any other HTML text, you can get as fancy as 
you want and embed font color and size changes, italicizing, and even <TT>&lt;IMG&gt;</TT> tag references.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Notice that the <TT>correct</TT> property of the <TT>Question</TT>
object is numeric, even though the buttons displayed to the user
show <TT>A</TT>, <TT>B</TT>, <TT>C</TT>,&#133;. You can define
the correct answer either way, by letter or number, just as long
as you remember to use the same representation throughout the
rest of your code, as will be the case in the next section.
<H2><A NAME="DisplayingaQuestion"><FONT SIZE=5 COLOR=#FF0000>
Displaying a Question</FONT></A></H2>
<P>
Displaying a given question involves nothing more than standard
HTML formatting, as shown by listing 26.3.
<HR>
<BLOCKQUOTE>
<B>Listing 26.3&nbsp;&nbsp;Displaying a Question<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
function DrawQuestion(iWhich) {
   var bodyDoc = window.body.document;
   var bannDoc = window.banner.document;

   bannDoc.write(&quot;&lt;HTML&gt;&quot; +
                 &quot;&lt;HEAD&gt;&lt;TITLE&gt;Question &quot; +
                 iWhich + &quot;&lt;/TITLE&gt;&lt;/HEAD&gt;&quot; +
                 &quot;&lt;BODY BGCOLOR=olive&gt;&quot; +
                 &quot;&lt;CENTER&gt;&quot; +
                 &quot;&lt;H1&gt;&lt;FONT COLOR=yellow&gt;&quot; +
                 &quot;Question #&quot; + iWhich + 
                 &quot;&lt;/FONT&gt;&lt;/H1&gt;&quot; +
                 &quot;&lt;/CENTER&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
   bannDoc.close();

   bodyDoc.write(&quot;&lt;HTML&gt;&quot; +
                 &quot;&lt;HEAD&gt;&lt;TITLE&gt;Question &quot; + 
                 iWhich + &quot;&lt;/TITLE&gt;&lt;/HEAD&gt;&quot; +
                 &quot;&lt;BODY BGCOLOR=#ffffff&gt;&quot;);

   bodyDoc.write(&quot;&lt;P&gt;&quot;);

   bodyDoc.write(&quot;&lt;I&gt;&lt;FONT SIZE=+2&gt;&quot; + 
                 Questions[iWhich].question + 
                 &quot;&lt;/FONT&gt;&lt;/I&gt;&quot;);

   bodyDoc.write(&quot;&lt;OL TYPE=A&gt;&quot;);

   for(var i=1; i&lt;=4; i++) {
      var tStr = eval(&quot;Questions[iWhich].ans&quot; + i);

      bodyDoc.write(&quot;&lt;LI&gt;&quot; + tStr + &quot;&lt;/LI&gt;&quot;);
   }

   bodyDoc.write(&quot;&lt;/OL&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);

   bodyDoc.close();

   if(window.nav.location.href.toString().indexOf(&quot;nav2.htm&quot;) == -1) {
      window.nav.location.href = &quot;nav2.htm&quot;;
   }

   iQuestion = iWhich;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Remember, the ordered list tag, <TT>&lt;OL&gt;</TT>, can be configured to display its list elements in a variety of ways-numeric, alphabetic, as roman numerals, even controlling upper- or lowercase through the <TT>STYLE</TT> attribute. In this example, 
<TT>STYLE</TT> is set to display the list as uppercase alphabetic selections, corresponding with the names of the multiple-choice buttons.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><BLOCKQUOTE>
<B>TIP</B>
</BLOCKQUOTE>
</TD>
</TR>
<TR><TD><BLOCKQUOTE>
Most of the time, JavaScript is capable of identifying what major object elements you are using based on context, without having to explicitly define the entire object heirarchy. For example, <I>under most conditions</I>:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>var bodyDoc = window.body.document;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
could be abbreviated to:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>var bodyDoc = body.document;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
However, as of JavaScript 1.1, the version running under Navigator 3.0, when you're trying to reference a frame element, as in this example, omitting the <TT>window.</TT> object reference causes JavaScript to try to associate <TT>body</TT> as a property of 

<TT>document</TT>, not <TT>window</TT>. Adding the <TT>window</TT> reference helps JavaScript identify the appropriate object structure, and everything works correctly.
</BLOCKQUOTE>
<BLOCKQUOTE>
When scripting in JavaScript, if you encounter a <TT>xxx</TT> <TT>is not an object</TT> or <TT>xxx not defined</TT> message, check to see if you're making shortcut assumptions and not specifying the complete object path (from <TT>window</TT>, or whatever 
the base object may be). In many cases, including the complete path corrects the problem.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<BLOCKQUOTE>
</BLOCKQUOTE>
<P>
The <TT>DrawQuestion()</TT> function performs the following different
steps:
<OL>
<LI>The <TT>banner</TT> frame is updated to reflect the new question
number.
<LI>The question itself is formatted, with the font size increased
slightly from the default for clarity. It also helps to fill up
the screen when the question is short and the user is surfing
at a high resolution.
<LI>The multiple-choice answers are formatted by stepping through
the list of possible solutions.
<LI>Finally, the document currently loaded in the <TT>nav</TT>
frame is looked at and the right navigation bar is loaded, if
necessary.
</OL>
<P>
This last step bears further discussion. When the user first enters
the question area, he or she is presented with the Welcome screen.
At this point, the <TT>nav</TT> frame contains one button: <TT>Begin</TT>.
Once the user has entered the quiz, however, the <TT>nav</TT>
frame needs to contain the multiple-choice selection buttons,
so a new page needs to be loaded, but only with the first question.
Reloading the page doesn't do any harm, but because the page itself
doesn't change between questions, reloading it is unnecessary.
<P>
To prevent unnecessary reloads, the line:
<BLOCKQUOTE>
<PRE>
if(window.nav.location.href.toString().indexOf(&quot;nav2.htm&quot;) == -1) {
</PRE>
</BLOCKQUOTE>
<P>
checks the <TT>href</TT> property of the location object for <TT>nav2.htm</TT>,
the name of the correct document file. If another file is loaded
within the <TT>nav</TT> frame, then a reload is performed to load
the correct document.
<P>
Another thing worth noting is how the multiple-choice answers
are obtained, which also explains why the <TT>correct</TT> property
stores the correct answer as a number not a letter, and why the
<TT>Answer()</TT> function expects the same numeric parameter.
The <TT>for</TT> loop:
<BLOCKQUOTE>
<PRE>
for(var i=1; i&lt;=4; i++) {
   var tStr = eval(&quot;Questions[iWhich].ans&quot; + i);
   bodyDoc.write(&quot;&lt;LI&gt;&quot; + tStr + &quot;&lt;/LI&gt;&quot;);
}
</PRE>
</BLOCKQUOTE>
<P>
constructs a JavaScript string like:
<BLOCKQUOTE>
<PRE>
Questions[iWhich].ansX
</PRE>
</BLOCKQUOTE>
<P>
where <TT>X</TT> is replaced with a number between 1 and 4, matching
the four answer properties of the <TT>Question</TT> object. Then,
the <TT>eval()</TT> function is used to force JavaScript to evaluate
the string like a regular statement-the end result being the value
stored in the associated property.
<H2><A NAME="HandlingtheAnswer"><FONT SIZE=5 COLOR=#FF0000>
Handling the Answer</FONT></A></H2>
<P>
When the user clicks one of the answer buttons, which are formatted
by the HTML source in listing 26.4, the <TT>Answer()</TT> function
is fired.
<HR>
<BLOCKQUOTE>
<B>Listing 26.4&nbsp;&nbsp;The Answer Buttons<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;CENTER&gt;&lt;FORM&gt;&lt;TABLE BORDER=3 CELLPADDING=0 CELLSPACING=0&gt;
   &lt;TR&gt;
      &lt;TD&gt;
         &lt;INPUT TYPE=BUTTON VALUE=&quot;A&quot;
                onClick=&quot;parent.Answer(1);&quot;&gt;
      &lt;/TD&gt;&lt;TD&gt;
         &lt;INPUT TYPE=BUTTON VALUE=&quot;B&quot;
                onClick=&quot;parent.Answer(2);&quot;&gt;
      &lt;/TD&gt;&lt;TD&gt;
         &lt;INPUT TYPE=BUTTON VALUE=&quot;C&quot;
                onClick=&quot;parent.Answer(3);&quot;&gt;
      &lt;/TD&gt;&lt;TD&gt;
         &lt;INPUT TYPE=BUTTON VALUE=&quot;D&quot;
                onClick=&quot;parent.Answer(4);&quot;&gt;
      &lt;/TD&gt;
   &lt;/TR&gt;
&lt;/TABLE&gt;&lt;/FORM&gt;&lt;/CENTER&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The job of <TT>Answer()</TT> (see listing 26.5) is to do the following:
<OL>
<LI>Determine whether the user's answer is correct.
<LI>Display an appropriate response (<TT>Good Job!</TT> or <TT>Not</TT>
<TT>quite</TT>, &#133;)
<LI>If the user was correct, increment a counter to keep track
of right answers.
<LI>Instruct the question engine to display the next question,
if there is a next question; otherwise, display the user's final
score.
</OL>
<HR>
<BLOCKQUOTE>
<B>Listing 26.5&nbsp;&nbsp;Processing a User's Answer<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
var   iQuestion   = 0;
var   iCorrect    = 0;

...

function Answer(strWhich) {
   var strAlpha = &quot;ABCD&quot;;
   var iRight   = Questions[iQuestion].correct;

   if(strWhich == iRight) {
      alert(&quot;Correct!&quot;);
      iCorrect++;
   } else {
      alert(&quot;I'm sorry.\n&quot; +
            &quot;The correct answer was '&quot; +
            strAlpha.substring(iRight-1,iRight) + &quot;'.&quot;);
   }

   if(iQuestion == Questions.length) {
      FinalScore();
   } else {
      DrawQuestion(iQuestion+1);
   }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
When the user gets a question wrong, he or she is informed what
the correct answer was before moving on to the next question.
Because the correct answer is stored numerically and the answers
are listed alphabetically, a means of converting from a <TT>3</TT>
to a <TT>C</TT>, for example, is needed. The method used here
is to utilize a temporary string containing the correct answer
letters:
<BLOCKQUOTE>
<PRE>
var strAlpha = &quot;ABCD&quot;;
</PRE>
</BLOCKQUOTE>
<P>
The value of the correct answer is then retrieved from the <TT>Questions[]</TT>
array (where it's stored as a number):
<BLOCKQUOTE>
<PRE>
var iRight   = Questions[iQuestion].correct;
</PRE>
</BLOCKQUOTE>
<P>
and used as an index to extract the correct character from <TT>strAlpha</TT>:
<BLOCKQUOTE>
<PRE>
strAlpha.substring(iRight-1,iRight));
</PRE>
</BLOCKQUOTE>
<P>
The end result is an <TT>alert()</TT> dialog box similar to the
one shown in figure 26.2.
<P>
<A HREF="f26-2.gif"><B>Figure 26.2 :</B> <I>The substring trick used here converts
the numeric version of the correct answer to its alphabetic equivalent</I>.</A>
<H2><A NAME="AddingItAllUp"><FONT SIZE=5 COLOR=#FF0000>
Adding It All Up</FONT></A></H2>
<P>
After the user has finished the quiz, it's time to tally the score,
inform the user, and optionally, give him or her the opportunity
to submit his or her final score to the server for processing.
This is the responsibility of the <TT>FinalScore()</TT> function.
<P>
<TT>FinalScore()</TT> (see listing 26.6) replaces the documents
in <I>all</I> <I>three</I> frames:
<OL>
<LI>The <TT>banner</TT> frame becomes an <TT>All done</TT> message.
<LI>The <TT>body</TT> frame displays the user's score, and provides
a means for the user to enter her name and submit her score.
<LI>The <TT>nav</TT> frame becomes a flat-color window with no
buttons.
</OL>
<HR>
<BLOCKQUOTE>
<B>Listing 26.6&nbsp;&nbsp;Displaying the Final Score<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
function FinalScore() {
   var bannDoc = window.banner.document;
   bannDoc.write(&quot;&lt;HTML&gt;&quot; +
                 &quot;&lt;HEAD&gt;&lt;TITLE&gt;All Done!&quot; +
                 &quot;&lt;/TITLE&gt;&lt;/HEAD&gt;&quot; +
                 &quot;&lt;BODY BGCOLOR=olive&gt;&quot; +
                 &quot;&lt;CENTER&gt;&quot; +
                 &quot;&lt;H1&gt;&lt;FONT COLOR=yellow&gt;&quot; +
                 &quot;All Done!&lt;/FONT&gt;&lt;/H1&gt;&quot; +
                 &quot;&lt;/CENTER&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
   bannDoc.close();

   var navDoc = window.nav.document;
   navDoc.write(&quot;&lt;HTML&gt;&quot; +
                &quot;&lt;HEAD&gt;&lt;TITLE&gt;&lt;/TITLE&gt;&lt;/HEAD&gt;&quot; +
                &quot;&lt;BODY BGCOLOR=olive&gt;&quot; +
                &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
   navDoc.close();

   window.body.location.href = &quot;final.htm&quot;;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The middle frame document, which displays the score information,
is the only document that's actually loaded from the server. The
top and bottom frames are dynamically created.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
For security reasons, Netscape has restricted the amount of manipulation you can perform on form data within JavaScript through the <TT>onSubmit</TT> event. This is done in an attempt to keep the unscrupulous from creating silent submission forms that 
attempt to retrieve your e-mail address without your knowledge.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The middle frame pulls data from the parent document to both display
and transmit to the server. Listing 26.7 shows the code that drives
this document.
<HR>
<BLOCKQUOTE>
<B>Listing 26.7&nbsp;&nbsp;Submitting the Data<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;/HEAD&gt;
&lt;BODY BGCOLOR=white&gt;

&lt;CENTER&gt;

&lt;H2&gt;Your Score:&lt;/H2&gt;

&lt;HR&gt;

&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;
&lt;!--
document.write(&quot;Total problems: &quot; + parent.Questions.length);
document.write(&quot;&lt;P&gt;&quot;);
document.write(&quot;Correct problems: &quot; + parent.iCorrect);
document.write(&quot;&lt;HR&gt;&quot;);
// --&gt;
&lt;/SCRIPT&gt;

If you wish to submit your score, please fill in the data
below and press &lt;B&gt;Submit&lt;/B&gt;

&lt;P&gt;

&lt;FORM METHOD=POST ACTION=&quot;mailto:sjwalter@visi.com&quot;&gt;

&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;
&lt;!--

document.write('&lt;INPUT TYPE=HIDDEN NAME=&quot;total&quot; ' +
               'VALUE=&quot;' + parent.Questions.length + 
               '&quot;&gt;');

document.write('&lt;INPUT TYPE=HIDDEN NAME=&quot;correct&quot; ' +
               'VALUE=&quot;' + parent.iCorrect + '&quot;&gt;');

// --&gt;
&lt;/SCRIPT&gt;

Your name: &lt;INPUT TYPE=TEXT NAME=&quot;realname&quot; VALUE=&quot;&quot;&gt;

&lt;P&gt;

&lt;TABLE BORDER=3 CELLPADDING=0 CELLSPACING=0&gt;
   &lt;TR&gt;&lt;TD&gt;
         &lt;INPUT TYPE=SUBMIT VALUE=&quot;Submit&quot;&gt;
   &lt;/TD&gt;&lt;/TR&gt;
&lt;/TABLE&gt;

&lt;/FORM&gt;

&lt;/CENTER&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<P>
As you can see, JavaScript is used to load the data into the hidden
fields during the construction of the form.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
While you could use the <TT>onLoad</TT> event, which is fired after a document is completely loaded and before the page is displayed to the user, it's not currently supported by Internet Explorer.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>
From Here&#133;</FONT></A></H2>
<P>
With the growing popularity of home schooling, the ability to
provide online testing is going to become more of a selling point
for an educationally oriented Web site. The structure presented
here is easily expanded to handle just about anything you care
to teach.
<P>
For more information on related topics, check out:
<UL>
<LI><A HREF="ch13.htm" >Chapter 13</A>, &quot;Field Verification,&quot; shows you how
to validate data from within the server through CGI and how to
validate data from within the client through JavaScript.
<LI><A HREF="ch14.htm" >Chapter 14</A>, &quot;Form Processing,&quot; explains how to treat
a form as a front-end to the Internet mail system.
</UL>
<HR>

<CENTER><P><A HREF="ch25.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch27.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
