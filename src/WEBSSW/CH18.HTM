<HTML>
<HEAD>
<TITLE>Chapter 18 -- Online Store Product Searches</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;18</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Online Store Product Searches</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#UsingProductKeys">
Using Product Keys</A>
<LI><A HREF="#AllowingforPartialMatches">
Allowing for Partial Matches</A>
<LI><A HREF="#DisplayingtheSearchResults">
Displaying the Search Results</A>
<LI><A HREF="#FromHere">
From Here&#133;</A>
</UL>

<HR>
<P>
If you start to sell a large quantity of items through your online
store, it may take some time for users to poke through your catalog
to find just what they want. In cases like this, having some way
to search your selections is in order.
<H2><A NAME="UsingProductKeys"><FONT SIZE=5 COLOR=#FF0000>
Using Product Keys</FONT></A></H2>
<P>
<A HREF="ch16.htm" >Chapter 16</A>, &quot;Searching the Database,&quot; introduces the
concepts of search keys to make it easier to find information
in a database. To review, a <I>key</I> is a field within the database
used as match criterion to locate a particular record; in this
case, an item from the catalog.
<P>
Keys can work in two different ways: searching and sorting. Because
each product in the catalog has a unique number (the order code)
associated with it, that field would best be used for sorting,
with the other fields being used to search, as customers will
remember &quot;Parka&quot; more often than &quot;PK4256.&quot;
<P>
Within database jargon, the field on which you base your search
is referred to as a <I>search key</I>. Keys aren't limited to
just a single field-you could create a <I>complex key</I> that
consists of more than one field, such as state and last name,
which is especially valuable when several database records may
have the same information in one or more fields. Nor are keys
limited to using the entire field, such as when you wish to find
all entries in a database that start with &quot;W.&quot;
<P>
Alternatively, you could create a totally new field for tracking
purposes in which to store a custom key.
<P>
Regardless of how you construct your keys, you'll need to utilize
a relatively fast search algorithm, especially as your online
catalog grows. A good quick algorithm is the binary search from
chapter 16, &quot;Searching the Database,&quot; which splits the
database in half again and again looking for a matching key. Listing
18.1 takes a fresh look at the binary search, and introduces some
new tricks as well.
<HR>
<BLOCKQUOTE>
<B>Listing 18.1&nbsp;&nbsp;Locating a Record with a Binary Search
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
sub BinarySearch {
   local ($key, *catalog) = @_;
   local ($howMany, $first, $last);
   $howMany = @catalog;
   $first   = 0;
   $last    = $howMany - 1;

   while(true) {
      $index  = $first + ($last - $first) / 2;
      $testKey = split(/\|/, $keyField[$index], 2);
 
      if($testKey =~ /$key/) {
         break;
      }

      if($testKey &lt; $key) {
         # record comes before key
         $first = $index + 1;
      } elsif ($testKey &gt; $key) {
         # record comes after key
         $last = $index - 1;
      } else {
         # at this point, we've no match
         $index = $howMany;
      }
   }

   if ($index &lt; $howMany) {
      return $keyField[$index];
   } else {
      return null;
   }
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
This function takes two parameters, the first being the key to
search for, the second being the array to search. It returns the
matching record found, or null if no match was found. For example:
<BLOCKQUOTE>
<PRE>
$result = &amp;BinarySearch(&quot;P1512&quot;, *catalog);
</PRE>
</BLOCKQUOTE>
<P>
would search the <TT>@catalog</TT> array for a product whose code
is <TT>P1512</TT>.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
You'll note in the previous function call that the array, normally prefaced by an ampersand (@) was prefaced by an asterisk (*) when passed as a parameter. This is how you pass arrays (or any variable, for that matter) by reference from within 
Perl.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="AllowingforPartialMatches"><FONT SIZE=5 COLOR=#FF0000>
Allowing for Partial Matches</FONT></A></H2>
<P>
More than likely, your users will be looking for &quot;something
like&quot; or &quot;something that has the word <I>'modem'</I>
in it&quot; rather than searching for a specific instance. In
that case, the search engine should be designed to return more
than one possible answer, giving the user the opportunity to pick
from the results. Figure 18.1 is an example of such a catalog
search, taken from the home site of Egghead Discount Software
(<B><A HREF="http://www.egghead.com/">http://www.egghead.com/</A></B>).
<P>
<A HREF="f18-1.gif"><B>Figure 18.1 :</B> <I>An example page returned from a catalog
search at the Egghead Discount Software site. Depending on the
types of products you choose to sell, the data columns your search
will display can vary greatly</I>.</A>
<P>
Implementing a multiple-response search is a straightforward process
of pulling a sublist out of the master database list. Listing
18.2 demonstrates a code fragment that performs such a search,
building a mini-database of matching records in the list <TT>$results[]</TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 18.2&nbsp;&nbsp;Retrieving Multiple Records<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
# listDB contains the database records
# key is the desired key to match
#
$numItems = @listDB;
for ($index = 0; $index &lt; $numItems; $index++) {
   if ($listDB[$index] =~ /$key/) {
      push (@results, $listDB[$index]);
   }
}

if (@results) {
   # found some matches
} else {
   # no matches found
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
If you remember from chapter 16, &quot;Searching the Database,&quot;
this is based on the brute-force search algorithm. Because you're
looking for <I>all</I> references to <TT>$key</TT> within the
database, starting at the beginning and working your way to the
end is a practical method.
<P>
A side benefit of this trick is gained if you maintain the database
as a record list, with each entry containing all the fields of
the record, instead of cracking the individual records into field
elements. If the entire record is contained within a list entry,
the value in <TT>$key</TT> is checked against the entire record,
which includes all fields. If your database has several long fields,
such as a product title, product description, and product color,
this method checks <I>everywhere</I> for a possible match.
<H2><A NAME="DisplayingtheSearchResults"><FONT SIZE=5 COLOR=#FF0000>
Displaying the Search Results</FONT></A></H2>
<P>
Once the <TT>$results[]</TT> list has been created, displaying
it back to the user is done by creating a simple table, as shown
in listing 18.3.
<HR>
<BLOCKQUOTE>
<B>Listing 18.3&nbsp;&nbsp;Generating a Result Table<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
print &quot;Content-type: text/html\n\n&quot;;

print &quot;&lt;TABLE BORDER=3&gt;\n&quot;;
foreach $record (@results) {
   &amp;PrintLink ($record);
}
print &quot;&lt;/TABLE&gt;&quot;;
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The Perl <TT>foreach</TT> statement steps through the results
list one record at a time, passing the returned record off to
the <TT>PrintLink</TT> function. <TT>PrintLink</TT> (listing 18.4)
is the real workhorse, in that it generates the HTML table record,
creating the necessary hyperlink.
<HR>
<BLOCKQUOTE>
<B>Listing 18.4&nbsp;&nbsp;Creating a Product Link<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
sub PrintLink {
   local ($code, $desc, $price);

   # crack the record
   ($code, $desc, $price) = split (/\|/, $_[0]);

   # Build the entry
   print &quot;&lt;TR&gt;\n&quot;;
   print &quot;&lt;TD&gt;$code&lt;/TD&gt;\n&quot;;
   print &quot;&lt;TD&gt;&lt;A HREF=\&quot;$code.html\&quot;&gt;$desc&lt;/TD&gt;\n&quot;;
   print &quot;&lt;TD&gt;$price&lt;/TD&gt;\n&quot;;
   print &quot;&lt;TD&gt;&lt;A HREF=&quot;\&quot;/cgi-bin/order?$code\&quot;&gt;Purchase&lt;/A&gt;&lt;/TD&gt;\n&quot;;
   print &quot;&lt;/TR&gt;\n&quot;;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The last table element is a line to the order processing script
(the shopping cart), passing the product code to the cart for
storage. This makes it easy for customers to purchase a product
no matter where they are in your store. Remember a fundamental
rule of sales: &quot;Always ask for the sale.&quot; If you don't
give a browser an opportunity to buy-he or she won't.
<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>
From Here&#133;</FONT></A></H2>
<P>
In this chapter, you extended the functionality of your online
catalog to include searching the database for items. For more
information on ways to use these tricks, check out:
<UL>
<LI><A HREF="ch16.htm" >Chapter 16</A>, &quot;Searching the Database,&quot; shows you
how to speed up data access and use index files.
<LI><A HREF="ch21.htm" >Chapter 21</A>, &quot;Calendar of Events,&quot; demonstrates a
unique and simple way to implement an online calendar.
<LI><A HREF="ch26.htm" >Chapter 26</A>, &quot;Online Testing,&quot; explains how to use
JavaScript to implement a multiple choice test and how to dynamically
generate forms and hidden fields.
</UL>
<HR>

<CENTER><P><A HREF="ch17.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch19.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
