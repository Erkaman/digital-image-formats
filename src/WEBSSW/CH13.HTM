<HTML>
<HEAD>
<TITLE>Chapter 13 -- Field Verification</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;13</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Field Verification</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#ServerSideValidation">
Server-Side Validation</A>
<UL>
<LI><A HREF="#EmptyFields">
Empty Fields</A>
<LI><A HREF="#InvalidData1">
Invalid Data</A>
<LI><A HREF="#Ping">
Ping!</A>
<LI><A HREF="#ServerSideValidationinRetrospect">
Server-Side Validation in Retrospect</A>
</UL>
<LI><A HREF="#ClientSideValidation">
Client-Side Validation</A>
<UL>
<LI><A HREF="#Emptiness">
Emptiness</A>
<LI><A HREF="#InvalidData2">
Invalid Data</A>
<LI><A HREF="#ImplementingMoreDetailedErrorMessages">
Implementing More Detailed Error Messages</A>
</UL>
<LI><A HREF="#VBScript">
VBScript</A>
<LI><A HREF="#FromHere">
From Here&#133;</A>
</UL>

<HR>
<P>
Forms are useful for a variety of tasks. For example, you may
join a mailing list, place an order, or complete a survey. Only
the creativity of the Web designer limits the list. By design,
virtually anything can be entered into the fields of a form, but
it's the job of the server software to process it properly.
<P>
There are times, however, when it would be nice to make certain
that a form was filled out correctly. For example, if you're releasing
a new version of your company's software product to the Internet
for public testing (something that's very popular these days),
you probably want any potential downloader to fill out a form
so you can keep track of who's playing with your program. In cases
like this, ensuring that the user answers all your required questions
is vital. You might  want to know, for example, if the downloaders
used a fake e-mail address.
<H2><A NAME="ServerSideValidation"><FONT SIZE=5 COLOR=#FF0000>
Server-Side Validation</FONT></A></H2>
<P>
Validating form information from the server-side involves checking
the values that pass through the environment variables to the
CGI program. The simplest level of validation is making certain
that necessary fields were filled out and, if so, whether they
were filled out correctly.
<P>
Before you can test any fields, you need to load the field values
into memory. Under CGI, field data passes to the Perl script through
the <TT>CONTENT_LENGTH</TT> environment variable, with individual
field-name/field-value pairs separated by ampersands. The first
step in the cracking process is to take the data from <TT>CONTENT_LENGTH</TT>
and split it into individual name/value pairs:
<BLOCKQUOTE>
<PRE>
read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});
@pairs = split(/&amp;/, $buffer);
</PRE>
</BLOCKQUOTE>
<P>
Once the fields have been separated into individual elements in
the <TT>$pairs</TT> list, the next step creates a new array-<TT>$contents</TT>-that
has one entry for each field. This is demonstrated by the code
fragment in listing 13.1.
<HR>
<BLOCKQUOTE>
<B>Listing 13.1&nbsp;&nbsp;Creating a Named List of Form Fields
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
foreach $pair (@pairs) {
   ($name, $value) = split(/=/, $pair, 2);
   $value =~ tr/+/ /;
   $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack(&quot;C&quot;, hex($1))/eg;
   $contents{$name} = $value;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
The <TT>$contents</TT> list is referred to as a <I>named list</I>, because individual elements within the list are referenced by a name. In the case of <TT>$contents</TT>, the name corresponds to a name defined in the <TT>NAME</TT> attribute of a field 
from the form. For example, if one of the fields in the form was defined as follows:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>&lt;INPUT TYPE=TEXT NAME=REALNAME ...&gt;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
once the <TT>$contents</TT> list fills, there is a related element accessible like this:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>$contents{'REALNAME'</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="EmptyFields">
Empty Fields</A></H3>
<P>
Once the fields have been <I>cracked, </I>meaning they've been
converted from one long string of text into a list, checking the
required ones for <I>emptiness</I> (that is, fields that have
no data) is also straightforward. While all fields within a form
are sent back to the server for processing, fields with no data
have only their field name sent. The cracking loop above would
then assign nothing to <TT>$value</TT>, effectively putting an
&quot;empty string&quot; into the list for that particular field.
Perl logic allows you to check to see if a variable contains something
simply by using:
<BLOCKQUOTE>
<PRE>
if(variable) {
   # variable has data
} else {
   # variable has no data
}
</PRE>
</BLOCKQUOTE>
<P>
This means that you can easily test to see if a particular element
isn't initialized (see listing 13.2); but, if you wish to test
several fields, this can a bit cumbersome.
<HR>
<BLOCKQUOTE>
<B>Listing 13.2&nbsp;&nbsp;Simple Emptiness Testing<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
if(! $contents{'EMAIL'}) {
   # Warn user of the incomplete form
   exit;
}
...
</PRE>
</BLOCKQUOTE>
<HR>
<P>
An easier method would be to define a subroutine that generates
the HTML file that informs the user to complete the form. Use
the <TT>unless</TT> command to execute the function <I>unless</I>
a given field has a value (as shown in listing 13.3).
<HR>
<BLOCKQUOTE>
<B>Listing 13.3&nbsp;&nbsp;Centralizing Error Handling in a Subroutine
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
print &quot;Content-type: text/html\n\n&quot;;
...
sub emptyFields {
   print &quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Form Incomplete&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;;
   print &quot;&lt;BODY&gt;&quot;;
   print &quot;I'm sorry, the form wasn't completely filled out.&quot;;
   print &quot;&lt;P&gt;Please return to the form and try again.&quot;;
   print &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;;

   exit;
}
...
&amp;emptyFields unless $contents{'REALNAME'};
&amp;emptyFields unless $contents{'EMAIL'};
...
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="InvalidData1">
Invalid Data</A></H3>
<P>
Sometimes it's necessary (where possible) to test the <I>validity</I>
of field data. If your form has a field for an e-mail address,
you can make certain assumptions about what a valid e-mail address
contains-for example, an <TT>@</TT> sign between the username
and domain. Using the same <TT>unless</TT> command from listing
13.3, listing 13.4 demonstrates a quick test of an e-mail address
field.
<HR>
<BLOCKQUOTE>
<B>Listing 13.4&nbsp;&nbsp;Testing Field Validity<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
print &quot;Content-type: text/html\n\n&quot;;
...
sub InvalidEmail {
   print &quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Invalid Email Address&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;;
   print &quot;&lt;BODY&gt;&quot;;
   print &quot;I'm sorry, your email address wasn't valid.&quot;;
   print &quot;&lt;P&gt;Please return to the form and try again.&quot;;
   print &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;;

   exit;
}
...
&amp;InvalidEmail unless ($contents{'EMAIL'} =~ /@/);
...
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="Ping">
Ping!</A></H3>
<P>
The test in listing 13.4, however, doesn't prevent a user from
creating a totally fake name and domain; as long as he or she
gets the ampersand in the string, the test passes. A slightly
more rigorous test would involve ensuring that the domain given
is an actual server. One way of doing this is through the UNIX
program <I>ping</I>, which checks to see if the specified host
responds.
<P>
From the UNIX command prompt, <I>ping</I> is run as follows:
<BLOCKQUOTE>
<PRE>
ping hostname
</PRE>
</BLOCKQUOTE>
<P>
where <TT>hostname</TT> is the domain name you wish to ping (as
in <TT>visi.com</TT>). If the specified host is online and answers,
<I>ping</I> displays:
<BLOCKQUOTE>
<PRE>
hostname is alive
</PRE>
</BLOCKQUOTE>
<P>
On the other hand, if the host isn't valid, that is, the host
name can't be resolved from the DNS, <I>ping</I> displays:
<BLOCKQUOTE>
<PRE>
ping: unknown host hostname
</PRE>
</BLOCKQUOTE>
<P>
Testing the output of <I>ping</I> by searching the displayed string
for the word &quot;alive,&quot; for example, is one way to validate
a host, but there is an easier way. To run an external program,
like <I>ping</I> from inside Perl you use the <TT>system()</TT>
function, which returns the <I>exit code</I> of the UNIX command
specified:
<BLOCKQUOTE>
<PRE>
$exitCode = system('ping hostname');
</PRE>
</BLOCKQUOTE>
<P>
The exit code is a numeric value, and most UNIX programs follow
the same convention:
<BLOCKQUOTE>
If the statement is successful, the code returned is zero (0).
<BR>
If the statement generates an error, the code returned is something
<I>other</I> than zero.
</BLOCKQUOTE>
<P>
The exact number returned in the event of an error varies from
program to program (and each number implies a different type of
error), but for the purposes of testing host validity, you only
need to know if <TT>system()</TT> returned zero or not. Listing
13.5 demonstrates a Perl fragment that extracts the host name
from the e-mail address and tries to <I>ping</I> that host. If
the <I>ping</I> is unsuccessful, the <TT>InvalidEmail</TT> function
is executed.
<HR>
<BLOCKQUOTE>
<B>Listing 13.5&nbsp;&nbsp;Pinging a Host<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
...
($username, $host) = split('\@', $contents{'EMAIL'});
$host =~ s/([;&lt;&gt;\*\|'&amp;\$!?#\(\)\[\]\{\}:'&quot;\\])/\\$1/g;

&amp;InvalidEmail unless (system('ping $host &gt; /dev/null') == 0);
...
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Listing 13.5 also demonstrates two other points worth noting.
First, because the <I>ping</I> program generates a string that
is normally displayed, that is, written to standard output, by
redirecting the output to <TT>/dev/null</TT>, the display string
is thrown away so as to not appear within the user's browser.
Second, the second line:
<BLOCKQUOTE>
<PRE>
$host =~ s/([;&lt;&gt;\*\|'&amp;\$!?#\(\)\[\]\{\}:'&quot;\\])/\\$1/g;
</PRE>
</BLOCKQUOTE>
<P>
This takes the host name extracted and <I>escapes</I> any special
characters (called <I>metachar-acters</I>) that may be embedded
within it by prefacing them with a slash (\). This is necessary
because the value in <TT>$host</TT> becomes part of a command
string that is executed by <TT>system()</TT>, creating a possible
security risk. For example, if you didn't escape metacharacters,
and the user typed the following as an &quot;e-mail address&quot;:
<BLOCKQUOTE>
<PRE>
sjwalter@visi.com ; /bin/rm -rF /
</PRE>
</BLOCKQUOTE>
<P>
The <TT>system()</TT> command that would be generated would look
like:
<BLOCKQUOTE>
<PRE>
$exitCode = system('ping visi.com ; /bin/rm -rF /');
</PRE>
</BLOCKQUOTE>
<P>
You recognize the semicolon (;) as a Perl end-of-statement delimiter,
and it has the same effect in UNIX. UNIX also (like Perl) supports
&quot;statement stacking&quot; where multiple statements can be
placed on the same command line separated by semicolons. In effect,
the user has just requested that your system ping <TT>visi.com</TT>,
then run <TT>rm</TT> and erase your hard disk!
<P>
You can easily prevent this kind of hacking by rendering any metacharacters
harmless, which is done by <I>escaping</I> them. To do this, place
a slash in front of each character. This instructs UNIX to treat
the character as a <I>literal</I>, which is a plain old character,
and to ignore any special effects it may have. Using the previous
<TT>system()</TT> command as an example, escaping the line would
generate:
<BLOCKQUOTE>
<PRE>
$exitCode = system('ping visi.com \; \/bin\/rm -rF \/');
</PRE>
</BLOCKQUOTE>
<P>
which disables the ability to run other programs from inside your
scripts. This would also probably generate an error condition
inside <TT>system()</TT> depending on the actual command executed,
but at that point, the attempt to invade your system has been
successfully thwarted.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Another term often used for this method of escaping text to render it harmless is <I>sanitizing</I>.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="ServerSideValidationinRetrospect">
Server-Side Validation in Retrospect</A></H3>
<P>
This is just a simple look at validation from the server side.
You can always make your testing more involved. An example would
be to feed the domain name from the e-mail address through a nameserver
utility like <I>nslookup</I> to validate the domain, instead of
using ping. The downside of server-side validation is that:
<OL>
<LI>The form must be transmitted back to the server.
<LI>The server must spawn a process to run the CGI script.
<LI>The server must process the output from the script.
<LI>The processed data must be transmitted back to the user.
</OL>
<P>
This creates additional connection overhead that you can avoid
with a little creative client-side scripting.
<H2><A NAME="ClientSideValidation"><FONT SIZE=5 COLOR=#FF0000>
Client-Side Validation</FONT></A></H2>
<P>
JavaScript now enables you to pre-check your submitted forms before
transmitting them to the server. This reduces the connection overhead,
as well as making field validation <I>immediate</I> instead of
having to wait for the server to parse the form, validate the
data, and generate a response document.
<P>
To JavaScript, an HTML <TT>&lt;FORM&gt;</TT> is just another object
attached to the <TT>document</TT> object, with all its elements
seen as properties of the associated <TT>form</TT> object. To
intercept the form before it's posted to the server, you hook
the <TT>onSubmit</TT> event of the <TT>form</TT> object like this:
<BLOCKQUOTE>
<PRE>
&lt;FORM NAME=&quot;helpForm&quot; METHOD=POST
      ONSUBMIT=&quot;return Validate(this)&quot; ...&gt;
</PRE>
</BLOCKQUOTE>
<P>
<TT>Validate()</TT> is a JavaScript function you custom write
to deal with the fields of your form. The <TT>onSubmit</TT> handler
returns a value of <TT>true</TT> or <TT>false</TT>, which determines
whether a form is actually submitted or not. If <TT>onSubmit</TT>
returns <TT>true</TT>, form processing continues. If the return
value is <TT>false</TT>, the user is brought back to the form
just as he or she left it when he or she clicked the <TT>Submit</TT>
button.
<H3><A NAME="Emptiness">
Emptiness</A></H3>
<P>
Within JavaScript, an element is empty if it's either <TT>null</TT>
or an empty string (&quot;&quot;). Listing 13.6 is an example
of an <TT>isEmpty()</TT> function.
<HR>
<BLOCKQUOTE>
<B>Listing 13.6&nbsp;&nbsp;JavaScript Emptiness<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
function isEmpty(str) {
   return (str == null || str == &quot;&quot;);
}
</PRE>
</BLOCKQUOTE>
<P>
With this function, checking for a filled <TT>realname</TT> field
is simple:
<BLOCKQUOTE>
<PRE>
if(isEmpty(form.realname.value)) {
   alert(&quot;You must give me your name!&quot;);
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Remember that fields within a <TT>form</TT> object are not simple strings. They are actually objects with various properties that depend on the type of field. In the case of <TT>TEXT</TT> objects, the <TT>value</TT> property contains the data entered by 
the user.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="InvalidData2">
Invalid Data</A></H3>
<P>
Testing the validity of the data in JavaScript fields is also
straightforward. Because <TT>TEXT</TT> objects are strings, use
the <TT>indexOf()</TT> method to search for the presence of a
character sequence. If the character sequence isn't found, <TT>indexOf()</TT>
returns a value of <TT>-1</TT>, as demonstrated in listing 13.7.
<HR>
<BLOCKQUOTE>
<B>Listing 13.7&nbsp;&nbsp;E-Mail Field Testing<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
if(theForm.email.value.indexOf(&quot;@&quot;) == -1) {
   alert(&quot;\nEmail addresses are usually of the form:&quot; +
         &quot;\n\nsomebody@someplace\n\n&quot; +
         &quot;your's doesn't seem to be valid!&quot;);
}
</PRE>
</BLOCKQUOTE>
<HR>
<H3><A NAME="ImplementingMoreDetailedErrorMessages">
Implementing More Detailed Error Messages</A></H3>
<P>
Because JavaScript is running within the browser, field testing
is as fast as the user's computer. You can take advantage of this
added speed to provide some more descriptive responses when a
form isn't properly filled out.
<P>
The code in listing 13.8 sets up an array of strings, then demonstrates
an implementation of <TT>Validate()</TT> that displays a different
message depending on which fields were <I>not </I>completed.
<HR>
<BLOCKQUOTE>
<B>Listing 13.8&nbsp;&nbsp;Fancy Error Messages<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;
&lt;!-- begin hide
function initArray(size) {
   this.length = size;

   for(i = 1; i &lt;= size; i++) {
      this[i] = null;
   }

   return this;
}

msgCase     = new initArray(3);
msgCase[1]  = &quot;You need to include your email address!&quot;;
msgCase[2]  = &quot;You must include your name!&quot;;
msgCase[3]  = &quot;What?  A blank form?\nSorry, you need to fill it out first!&quot;;

function Validate(theForm) {
   iName    = isEmpty(theForm.realname.value) ? 1 : 0;
   iEmail   = isEmpty(theForm.email.value) ? 1 : 0;
   iCase    = (iName &lt;&lt; 1) | iEmail;

   if(iCase) {
      alert(&quot;\n&quot; + msgCase[iCase - 1]);
      return false;
   }

   // Low-level verification of email address
   //
   if(theForm.email.value.indexOf(&quot;@&quot;) == -1) {
      alert(&quot;\nEmail addresses are usually of the form:&quot; +
            &quot;\n\nsomebody@someplace\n\n&quot; +
            &quot;your's doesn't seem to be valid!&quot;);

      return false;
   }

   return true;
}
// end hide --&gt;
&lt;/SCRIPT&gt;
...
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The real essence of this script lies in the following lines:
<BLOCKQUOTE>
<PRE>
iName    = isEmpty(theForm.realname.value) ? 1 : 0;
iEmail   = isEmpty(theForm.email.value) ? 1 : 0;
</PRE>
</BLOCKQUOTE>
<P>
The variables <TT>iName</TT> and <TT>iEmail</TT> are set to <TT>1</TT>
or <TT>0</TT>, depending on whether the associated field is empty
or not. This seems logically backward, and it is, but it's necessary
in order for the following line to work:
<BLOCKQUOTE>
<PRE>
iCase    = (iName &lt;&lt; 1) | iEmail;
</PRE>
</BLOCKQUOTE>
<P>
The left-shift and bit-wise <TT>OR</TT> operators take the values
from &quot;iName&quot; and &quot;iEmail&quot; and construct a
number between 0 and 3. Depending on the number (&quot;iCase,&quot;),
a different message from the message array is sent back to the
user. If the <TT>realname</TT> field was empty, for example, but
the &quot;email&quot; field wasn't, &quot;iName&quot; would equal
1 and &quot;iEmail&quot; would be 0. Feeding these values through
the line above would set &quot;iCase&quot; to 2. If you look at
<TT>msgCase[2]</TT> you'll find that the stored string is:
<BLOCKQUOTE>
<PRE>
You must include your name!
</PRE>
</BLOCKQUOTE>
<P>
which is exactly the field that's empty. After you've figured
out all the possible combinations of emptiness, this helpful hint
makes dealing with a large number of empty fields much simpler.
<H2><A NAME="VBScript"><FONT SIZE=5 COLOR=#FF0000>
VBScript</FONT></A></H2>
<P>
VBScript follows much the same structure as JavaScript, with some
minor syntactical differences. The easiest way to get a feeling
for how the two languages differ is to simply compare them in
action. Listing 13.9 is the same code block as shown in listing
13.8, but written in VBScript.
<HR>
<BLOCKQUOTE>
<B>Listing 13.9&nbsp;&nbsp;Error Messages in VBScript<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;SCRIPT LANGUAGE=&quot;VBScript&quot;&gt;
function isEmpty(field)
   isEmpty = (field.value = &quot;&quot;)
end function

Dim CR
CR = chr(13)

Dim msgCase(7)
msgCase(1)  = &quot;You need to submit a comment as well,&quot; &amp; CR &amp; 
&quot;not just your name and address!&quot;
msgCase(2)  = &quot;You need to include your email address!&quot;
msgCase(3)  = &quot;You have to give me more than just your name!&quot;
msgCase(4)  = &quot;You must include your name!&quot;
msgCase(5)  = &quot;You have to give me more than just your email address!&quot;
msgCase(6)  = &quot;You need to include your name and address!&quot;
msgCase(7)  = &quot;What?  A blank form?&quot; &amp; CR &amp; 
&quot;Sorry, you need to fill it out first!&quot;

function Validate()
   Dim iName, iEmail, iText, iCase
   iName = iEmail = iText = iCase = 0

   if isEmpty(document.commentForm.realname) then
      iName = 1
   end if

   if isEmpty(document.commentForm.email) then
      iEmail = 1
   end if

   if isEmpty(document.commentForm.comment) then
      iText = 1
   end if

   Validate = true

   iCase    = (iName * 4 ) + (iEmail * 2) + iText

   if(iCase) then
      MsgBox msgCase(iCase)
      Validate = false
   elseif (not (theForm.use.checked or theForm.donotuse.checked))  then
      Msgbox CR &amp; &quot;You need to tell me whether I can use&quot; &amp; CR &amp; 
      &quot;your comments or not!&quot;
      Validate = false
   elseif(theForm.email.value.indexOf(&quot;@&quot;) = -1) then
      MsgBox CR &amp; &quot;Email addresses are usually of the form:&quot; &amp; CR &amp; 
      CR &amp; &quot;somebody@someplace&quot; &amp; CR &amp; CR 
      &quot;your's doesn't seem to be valid!&quot;

      Validate = false
   end if
end function
&lt;/SCRIPT&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<P>
As you can see, the differences are subtle and purely language-syntactical
as follows: 
<BLOCKQUOTE>
Functions in VBScript return values by setting the function name
equal to the value you wish to return.
</BLOCKQUOTE>
<BLOCKQUOTE>
Semicolons aren't used to terminate a command because the carriage
return becomes the &quot;newline&quot; indicator.
</BLOCKQUOTE>
<BLOCKQUOTE>
Arrays (and variables) are defined with the <TT>Dim</TT> statement,
rather than having to write a special array function. Once created,
individual array elements are accessed using parentheses instead
of square brackets.
</BLOCKQUOTE>
<BLOCKQUOTE>
The <TT>MsgBox</TT> function replaces <TT>alert()</TT>.
</BLOCKQUOTE>
<BLOCKQUOTE>
Testing for an empty field involves comparing the <TT>value</TT>
property of the field against an empty string (&quot;&quot;).
</BLOCKQUOTE>
<BLOCKQUOTE>
Embedding carriage returns within a large string to format the
output in <TT>MsgBox</TT> is done by embedding a <TT>chr(13)</TT>
command or a character variable that contains the character instead
of the JavaScript &quot;\n&quot; character.
</BLOCKQUOTE>
<BLOCKQUOTE>
Rather than doing bit-wise math on the <TT>iCase</TT> variable,
simple multiplication and addition is used.
</BLOCKQUOTE>
<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>
From Here&#133;</FONT></A></H2>
<P>
This chapter demonstrates how you double-check the validity of
the data in submitted forms, both before the server gets the information
and after. For related information, check out:
<UL>
<LI><A HREF="ch6.htm" >Chapter 6</A> &quot;Controlling User Access,&quot; for information
about site security.
<LI><A HREF="ch12.htm" >Chapter 12</A>, &quot;Guestbook/Graffiti Wall,&quot; to learn
to create a database of visitors to your site.
<LI><A HREF="ch14.htm" >Chapter 14</A>, &quot;Form Processing,&quot; on how to use forms
to process e-mail.
</UL>
<HR>

<CENTER><P><A HREF="ch12.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch14.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
