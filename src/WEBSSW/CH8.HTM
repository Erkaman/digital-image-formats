<HTML>
<HEAD>
<TITLE>Chapter 8 -- Advertising with Billboards</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;8</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Advertising with Billboards</FONT>
</H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#ServerSideBillboards">
Server-Side Billboards</A>
<UL>
<LI><A HREF="#ABillboardDatabase">
A Billboard Database</A>
</UL>
<LI><A HREF="#ClientSideBillboards">
Client-Side Billboards</A>
<UL>
<LI><A HREF="#UserDefinedObjects">
User-Defined Objects</A>
<LI><A HREF="#AnArrayBasedDatabase">
An Array-Based Database</A>
<LI><A HREF="#JavaScriptGeneratedHTML">
JavaScript-Generated HTML</A>
</UL>
<LI><A HREF="#FromHere">
From Here&#133;</A>
</UL>

<HR>
<P>
The Internet was funded by the National Science Foundation; however,
with the entry of the everyday user into Cyberspace, that funding
was eliminated a few years ago. This places the burden of paying
for the hardware, software, and telephone connections on the private
sector. This expense is felt by all of us, directly or indirectly.
It becomes clear as you surf the Web through an ever increasing
number of sites that display advertising from a variety of clients.
A common method of displaying advertisements is in the form of
a &quot;banner&quot; or &quot;billboard&quot; graphic which, when
clicked, takes the user directly to the advertiser's site.
<P>
Whether you agree with Web advertising or not, at some point in
time you may encounter a situation where you'll need to incorporate
it into a site.
<H2><A NAME="ServerSideBillboards"><FONT SIZE=5 COLOR=#FF0000>
Server-Side Billboards</FONT></A></H2>
<P>
If you have access to the CGI layer of your Web server, it's simple
to maintain a list of advertisers and display graphic hyperlinks.
Two separate files are required:
<OL>
<LI>A database of advertisers with a hyperlink URL and an image
URL for each billboard advertisement.
<LI>A Perl script that dynamically generates an HTML page for
the user's browser, inserting a different advertiser's information
each time it's called.
</OL>
<P>
As with all scripts in this book, the full source code is found
on the companion CD-ROM. The following sections touch on the code's
highlights.
<H3><A NAME="ABillboardDatabase">
A Billboard Database</A></H3>
<P>
The &quot;billboard database&quot; is as simple as a flat text
file with one advertiser per line. Each line or <I>record</I>
needs to contain two fields:
<OL>
<LI>The URL of the billboard image to display.
<LI>The URL of the link to jump to when the image is clicked.
</OL>
<P>
The easiest way to handle this is to use a <I>delimiter</I> as
a field separator. A <I>delimiter</I> is a character that never
occurs in either field. Because Perl is a wonderful text processor,
parsing a line into individual fields is simple. For example,
assuming that the <TT>|</TT> character was used as a delimiter,
a sample database would look something like:
<BLOCKQUOTE>
<PRE>
eff_gry_lg.gif|http://www.eff.org/
cigjs.gif|http://www.visi.com/~sjwalter/javascript/
</PRE>
</BLOCKQUOTE>
<P>
A Perl fragment that demonstrates how to load a flat text file
into two Perl arrays, one for image URLs, one for hyperlinks,
is shown in listing 8.1.
<HR>
<BLOCKQUOTE>
<B>Listing 8.1&nbsp;&nbsp;Parsing the Database<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
open (BILLBOARDS, 'billboards.dat');

while (&lt;BILLBOARDS&gt;) {
   ($image, $url) = split (/\|/, $_);
   chop $url;
   push (@imageURLs, $image);
   push (@linkURLs , $url);
}

close (BILLBOARDS);
</PRE>
</BLOCKQUOTE>
<HR>
<P>
When the <TT>while</TT> loop is finished, &quot;imageURLs&quot;
and &quot;linkURLs&quot; contain all the image and hyperlink URLs
from the database. Selecting a pair of URLs randomly then involves
generating a random number:
<BLOCKQUOTE>
<PRE>
$which = int(rand(@imageURL));
</PRE>
</BLOCKQUOTE>
<P>
and using it to index into the respective arrays:
<BLOCKQUOTE>
<PRE>
$theImage = $imageURLs[$which];
$theLink  = $linkURLs[$which];Dynamically Generating HTML
</PRE>
</BLOCKQUOTE>
<P>
<A HREF="ch1.htm" >Chapter 1</A> &quot;Browser Identification,&quot; introduced a method
of wrapping HTML files with a CGI script that selects different
files based on the specific type of browser. Once the correct
HTML file was identified, it was opened and sent from Perl back
to the server for transmission to the browser. The same technique
must be used here, because Perl needs to process the HTML file
before the server feeds it back to the browser.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
An alternative technique would be to use <I>server-side includes</I>. This technique enables you to embed references to CGI scripts into your HTML files. These server-processed files (<I>included</I> in the data stream) then pass to the browser.
</BLOCKQUOTE>
<BLOCKQUOTE>
For an example of billboards built around server-side includes, see the companion CD-ROM.&nbsp;
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The code fragment that handles the file opening and processing
task is shown in listing 8.2.
<HR>
<BLOCKQUOTE>
<B>Listing 8.2&nbsp;&nbsp;Opening and &quot;Printing&quot; a File
through Perl<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
print &quot;Content-type: text/html\n\n&quot;;
...
open (HTML, &quot;&lt;&quot;, $htmlFile);

while (&lt;HTML&gt;) {
   print;
}

close (HTML);
</PRE>
</BLOCKQUOTE>
<HR>
<P>
The <TT>while</TT> loop does the bulk of the work, and reads in
the HTML document one line at a time and prints it back to standard
output. From inside CGI, standard output corresponds to the input
stream of the server which turns around and sends the data back
to the browser for formatting.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>A Little File Trick in Perl</B></TD></TR>
<TR><TD><BR>
<BLOCKQUOTE>
If you didn't have to parse the file and just wanted to send it from the server to the user's browser, you could dispense with the <TT>while</TT> loop altogether:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>open (HTML, &quot;&lt;$htmlFile&quot;);</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>print &lt;HTML&gt;;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>close (HTML);</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
which would route the entire file directly to standard output; that is, back to the server and on to the user. This is especially good if you want to send an image file (a graphic) from the server:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>open (GIF, &quot;&lt;myimage.gif&quot;);</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>print &lt;GIF&gt;;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>close (GIF);</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
However, if you are going to send a graphic, you should also turn off buffering, as CGI scripts are usually &quot;buffered&quot; and don't actually transmit their data until they finish, with the following statements <I>before</I> the code that transmits 
the image file:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>    select(stdout);</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>    $| = 1;</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Inside the <TT>while</TT> block, you have access to a new line
from the HTML file with each iteration through the loop. This
means that you can examine each line for a <I>flag</I>, or <I>token</I>,
and replace the flag with some custom HTML. One example is the
link for the billboard, and this is exactly how the billboard
system works.
<P>
For example, if the following line were used as a placeholder
for an advertisement:
<BLOCKQUOTE>
<PRE>
&lt;!-- BILLBOARD --&gt;
</PRE>
</BLOCKQUOTE>
<P>
modifying the <TT>while</TT> loop to:
<BLOCKQUOTE>
<PRE>
while (&lt;HTML&gt;) {
   if(/\&lt;\!-- BILLBOARD --\&gt;/) {
      print &amp;BillboardLink;
   } else {
      print &quot;$_&quot;;
   }
}
</PRE>
</BLOCKQUOTE>
<P>
would replace any references to <TT>&lt;!-- BILLBOARD --&gt;</TT>
with a hyperlink and graphic from the database of advertisers.
The <TT>BillboardLink</TT> function does the actual HTML creation,
and takes the randomly selected billboard and formats the HTML
tags (see listing 8.3).
<HR>
<BLOCKQUOTE>
<B>Listing 8.3&nbsp;&nbsp;Perl-Generated HTML<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
sub BillboardLink {
   $which = int(rand(@imageURL));
   print &quot;&lt;A HREF=\&quot;$imageURLs[$which]\&quot;&gt;&quot;;
   print &quot;&lt;IMG SRC=\&quot;$linkURLs[$which]\&quot;&gt;&lt;/A&gt;&quot;;
}
</PRE>
</BLOCKQUOTE>
<HR>
<H2><A NAME="ClientSideBillboards"><FONT SIZE=5 COLOR=#FF0000>
Client-Side Billboards</FONT></A></H2>
<P>
For security reasons, VBScript and JavaScript, like databases,
aren't permitted to load external files from the server. To get
around this, you need to incorporate the billboard database into
the HTML file. This can be done in one of two ways:
<OL>
<LI>As data stored in hidden fields of a &lt;FORM&gt; object.
<LI>As data stored in an array of user-defined script objects.
</OL>
<P>
Source codes for both methods are on the companion CD-ROM. The
second method does use some additional tricks that warrant further
discussion in the following section.
<H3><A NAME="UserDefinedObjects">
User-Defined Objects</A></H3>
<P>
While JavaScript provides a basic collection of objects dealing
with various parts of the browser, the billboard database needs
a customized object with two properties: the URL of the image
to display and the URL of the associated hyperlink. This requires
creating a <I>user-defined</I> object.
<P>
To create your own objects, you first need to write a function
whose name is the same as the object you wish to define (like
<TT>Billboard</TT>). Initialize any properties of the object within
the body of the function. For the billboard database, each object
is one graphic with its associated link, so the initializer function
would look like the one shown in listing 8.4.
<HR>
<BLOCKQUOTE>
<B>Listing 8.4&nbsp;&nbsp;Defining a Billboard Object<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
function Billboard(strImageURL, strLinkURL) {
   this.imageURL = strImageURL;
   this.linkURL  = strLinkURL;
   return this;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
User-defined objects can also hold methods as well as properties. If you wish to associate a method to an object, you must first define the function</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>function aNewFunction(...) {</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>   ...</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>}</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
then hook it to a property of the object in the constructor function:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>this.aNewFunction = aNewFunction;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
Once this is done, whenever a new object of this type is created, it will also have the <TT>aNewFunction()</TT> method associated with it. An example of this trick in action is available on the CD-ROM.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Now that the initializer function is defined, creating new <TT>Billboard</TT>
objects is as simple as using the JavaScript <TT>new</TT> operator:
<BLOCKQUOTE>
<PRE>
myBillboard = new Billboard('ad.gif', 'http://mysite.com/');<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>TIP</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
A parameter that does not pass to the function even though the function specifies it, is considered not defined.</BLOCKQUOTE>
<BLOCKQUOTE>
In JavaScript, any parameter that's not defined is assumed to be <TT>null</TT>, so a statement such as:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>anotherBillboard = new Billboard();</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
is valid, and would create a Billboard object with both its properties set to null. This is a handy trick when you want to allocate space for an object, but you won't know what the property values are until later. These reveal, for example, when computed 
by another function or retrieved from a form.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Once you create objects, you access them and their properties
the same way you would access any of the built-in objects of JavaScript.
<H3><A NAME="AnArrayBasedDatabase">
An Array-Based Database</A></H3>
<P>
Creating an <I>array</I> is an excellent way to make your advertisement
objects easier to handle. Arrays are constructed in a manner similar
to building user-defined objects. First, create a function that
initializes the array, then fill it with objects. An array-creation
function (listing 8.5) differs from an object-creation function
in that it has <I>elements</I> (accessed through subscripts) instead
of <I>properties</I>. Each element is an independent object. The
one property an array <I>does</I> have is the <TT>length</TT>
property, which holds the size, or number of elements and objects
of the array.
<HR>
<BLOCKQUOTE>
<B>Listing 8.5&nbsp;&nbsp;Initializing an Array<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
function initArray(iSize) {
   this.length = iSize;

   for(var i=1; i&lt;=iSize; i++)
      this[i] = null;

   return this;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><BLOCKQUOTE>
<B>CAUTION</B>
</BLOCKQUOTE>

</TD></TR>
<TR><TD><BLOCKQUOTE>
With the release of Navigator 3.0, Netscape has extended JavaScript to include a real <TT>Array</TT> object. However, because this is only supported by Navigator 3.0, the method shown in listing 8.5 is still the recommended technique (until surfers stop 
using Navigator 2.x and Internet Explorer catches up).
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><BLOCKQUOTE>
<B>Array Indexes in JavaScript</B>
</BLOCKQUOTE>

</TD></TR>
<TR><TD><BLOCKQUOTE>
If you were to examine the source code on various sites around the Web, you may find a function similar to <TT>initArray()</TT>, but with a <TT>for</TT> loop that starts at 0 instead of 1:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>for(var i=0; i&lt;iSize; i++)</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>   this[i] = null;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
with the element indexing starting at 0 as well. If all the array holds is simple <I>properties</I>, this doesn't cause a problem, which is why many pages that initialize arrays in this manner still work. However, if the array elements are <I>objects</I> 
(either built-in or user-defined), this method has the side effect of destroying the value stored in the <TT>length</TT> property, making the array more difficult to manage.
</BLOCKQUOTE>
<BLOCKQUOTE>
Whether dealing with properties or objects, it's best to index your arrays from 1 instead of 0.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
With the function defined, creating the array and loading it with
advertisers becomes simple:
<BLOCKQUOTE>
<PRE>
advertisers    = initArray(5); // 5-element array
advertisers[1] = new Billboard(...);
...
advertisers[5] = new Billboard(...);<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>TIP</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
If you aren't sure how big an array should be, don't worry. JavaScript supports <I>dynamic resizing</I>, which enables you to initialize additional elements long after you originally created the array. For example, if you started with an array of 10 
elements:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>myArray = new initArray(10);</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
And you need to store an additional (11th) element, just store it:</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>myArray[11] = newElement;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
and JavaScript takes care of the rest. It even includes updating the value stored in the <TT>length</TT> property to reflect the new size of the array. Just remember that whatever new element you initialize, the size of the new array also includes any 
elements between the new element and the previous high index. In other words, if you started with 10-element array and added an element at index 100:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>myArray[100] = newElement;</TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
&quot;myArray&quot; would be resized to also initialize elements 11 through 99 (to null).</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="JavaScriptGeneratedHTML">
JavaScript-Generated HTML</A></H3>
<P>
With the basis for the billboard database finished, all that's
left to write is the code to generate the hotlink and graphic
tag for a randomly selected advertiser from the database. A demonstration
of the script fragment that selects an advertiser and constructs
the HTML code from the <TT>advertisers</TT> array built earlier
appears in listing 8.6.
<HR>
<BLOCKQUOTE>
<B>Listing 8.6&nbsp;&nbsp;Pick an </B><I>Advertiser</I>, <B>Any
</B><I>Advertiser<BR>
</I>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
 ...
advertisers    = new initArray(5);
advertisers[1] = new Billboard(...);
...

function random(iMax) {
   var now  = new Date();
   var time = now.getTime();

   return (time / 10) % iMax;
}

function buildHTML() {
   var iWhich = random(advertisers.length);

   return &quot;&lt;A HREF=\&quot;&quot; + advertisers[iWhich].linkURL + &quot;\&quot; &quot; +
          &quot;TARGET=\&quot;_top\&quot;&gt;&lt;IMG SRC=\&quot;&quot; +
          advertisers[iWhich].imageURL + &quot;\&quot;&gt;&quot;;
}
</PRE>
</BLOCKQUOTE>
<HR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>TIP</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
While not shown in the above example, it's a good idea to include <TT>WIDTH</TT> and <TT>HEIGHT</TT> attributes in your <TT>&lt;IMG&gt;</TT> tags for two reasons. First, some versions and platforms of Navigator may crash when asked to display an object 
that isn't pre-sized by the attributes.
</BLOCKQUOTE>
<BLOCKQUOTE>
Second, and perhaps more important, the inclusion of <TT>WIDTH</TT> and <TT>HEIGHT</TT> speeds up page loading. When a browser is given an image without size designations, extra steps and time must be taken to read that information from the image file. 
This delays the page from formatting until that information retrieves. Adding the <TT>WIDTH</TT> and <TT>HEIGHT</TT> attributes lets the browser layout the page as quickly as possible.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Unless your site is configured with frames, the inclusion of the
<TT>TARGET</TT> attribute isn't necessary. It's a nice touch,
however, that ensures that your advertiser gets complete run of
the browser's client area. Calling the <TT>buildHTML()</TT> function
from inside the HTML body itself is academic:
<BLOCKQUOTE>
<PRE>
document.write(buildHTML());
</PRE>
</BLOCKQUOTE>
<P>
and can be placed anywhere-centered on the page, in a table for
automatic formatting, or in a separate frame.
<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>
From Here&#133;</FONT></A></H2>
<P>
This chapter introduces several tricks for automating advertising
on your Web pages, and also shows you how to handle scripting
arrays consisting of complex objects. For more information on
related tricks, check out:
<UL>
<LI><A HREF="ch2.htm" >Chapter 2</A> &quot;Plug-In Identification,&quot; teaches you
how to embed multimedia files in HTML and identify whether a plug-in
is installed in the user's browser.
<LI><A HREF="ch7.htm" >Chapter 7</A> &quot;Animating Images,&quot; shows you how to
implement client-pull and create animated GIFs.
<LI><A HREF="ch15.htm" >Chapter 15</A>, &quot;Managing a Database,&quot; is all about
how to create and maintain a database.
<LI><A HREF="ch17.htm" >Chapter 17</A>, &quot;Creating Online Catalogs,&quot; explains
how to create an online mall and how to set up a catalog of your
products.
<LI><A HREF="ch24.htm" >Chapter 24</A>, &quot;Designing an eZine,&quot; demonstrates centralizing
script-code into one file and optimizing frame display to make
the most of browsers that suport framewidth.
</UL>
<HR>

<CENTER><P><A HREF="ch7.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch9.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
