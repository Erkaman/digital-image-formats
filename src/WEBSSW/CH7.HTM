<HTML>
<HEAD>
<TITLE>Chapter 7 -- Animating Images</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.0z">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;7</FONT></H1>
<H1><FONT SIZE=6 COLOR=#FF0000>Animating Images</FONT></H1>
<HR>
<P>
<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>
<UL>
<LI><A HREF="#HTMLBasedAnimation">
HTML-Based Animation</A>
<LI><A HREF="#ClientPull">
Client-Pull</A>
<UL>
<LI><A HREF="#HTMLBasedClientPull">
HTML-Based Client-Pull</A>
<LI><A HREF="#JavaScriptClientPull">
JavaScript Client-Pull</A>
</UL>
<LI><A HREF="#AnimatedGIFs">
Animated GIFs</A>
<LI><A HREF="#DynamicIltIMGgtITagManipulation">
Dynamic <I>&lt;IMG&gt;</I> Tag Manipulation</A>
<UL>
<LI><A HREF="#TheIImageIObject">
The <I>Image</I> Object</A>
<LI><A HREF="#CachedImages">
Cached Images</A>
</UL>
<LI><A HREF="#FromHere">
From Here&#133;</A>
</UL>

<HR>
<P>
The Web wouldn't be much to look at these days with-out graphics.
Graphics are <I>definitely</I> in abundance in Cyberspace, but
even graphics can become boring for many if they don't <I>move</I>.
One way to liven up your Web pages is to incorporate animation
files, such as .AVI, .FLI, or .MOV, but these require the user
to either have external (helper) applications to view the files
or install plug-ins into the browser. Fortunately, there are other
methods of animation that don't rely on external additions to
the Web interface.
<H2><A NAME="HTMLBasedAnimation"><FONT SIZE=5 COLOR=#FF0000>
HTML-Based Animation</FONT></A></H2>
<P>
The simplest method of image animation takes advantage of two
attributes of the <TT>&lt;IMG&gt;</TT> tag:  <TT>SRC</TT> and
<TT>LOWSRC</TT>. Both specify image files to load and display.
The difference between them is the <I>order</I> in which the graphics
are loaded. If the <TT>LOWSRC</TT> attribute is specified, the
browser loads the associated image <I>first</I>, followed by the
<TT>SRC</TT> attribute's image, regardless of the order the attributes
are specified within the <TT>&lt;IMAGE&gt;</TT> tag.
<P>
The original intention of the <TT>LOWSRC</TT> attribute was to
help combat the amount of time it takes to retrieve an image from
a server. With <TT>LOWSRC</TT>, you could specify a &quot;low-resolution&quot;
image, perhaps limited to a simple black-and-white bit map. This
was very small and would load quickly, giving the user something
to look at while the high-resolution (full-color) image was retrieved.
<P>
Because <TT>LOWSRC</TT> only indicates an image (any kind) to
be loaded <I>first</I>, you can just as easily load two different
images. This gives you a &quot;before-and-after&quot; effect.
An example of this technique, which is found on the Web at <B><A HREF="http://www.winternet.com/~thepulse/">http://www.winternet.com/~thepulse/</A></B>,
is shown in figure 7.1.
<P>
<A HREF="f7-1.gif"><B>Figure 7.1 :</B> <I>Using <FONT SIZE=1 FACE="MCPdigital">LOWSRC</FONT>
and <FONT SIZE=1 FACE="MCPdigital">SRC</FONT> allows this site
to make the airbrush in the logo squirt paint</I>.</A>
<P>
The logo graphic in the center of the screen is actually two separate
image files. The final image with a splash of paint spraying from
the tip of the airbrush, and the <TT>LOWSRC</TT> image without
the paint spray. Other than that, the images are identical. Link
to this site and the logo displays. After a short downloading
time, the paint sprays from the brush's tip.
<P>
There are a few things to remember when using this method:
<UL>
<LI>The delay between images is contingent on the amount of material
(other objects) that must retrieve for the page, the size of the
images, and the speed of the user's connection. Not all images
lend themselves well to this trick, and if a user is surfing with
a high-speed connection (such as T1, Frame relay, or ISDN), he
or she will probably not notice the animation at all.
<LI>Once both images store in the browser's local cache, the animation
effect is lost until the user clears the cache.
<LI>The <TT>LOWSRC</TT> image can be an interlaced GIF or progressive
JPEG for added effect, but the <TT>SRC</TT> image is best if it's
a <I>transparent</I> GIF. Loading an interlaced GIF over the previous
image re-blurs the image, while a non-transparent image produces
a noticeable &quot;wipe.&quot;
<LI>As with all image loading, <I>speed is critical</I>. If your
graphics get too fancy, the animation effect is lost on the user.
</UL>
<P>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>TIP</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
With Navigator 3.0 and Internet Explorer 3.0, the space occupied by an <TT>&lt;IMG&gt;</TT> tag displays on the screen as a beveled outline with a miniature image icon inside until the graphic completely loads. If you're trying to get fancy and have a 
transparent GIF overlay your background, this outlining defeats the purpose.
</BLOCKQUOTE>
<BLOCKQUOTE>
To get around this, specify a <TT>LOWSRC</TT> attribute that loads a small graphic that's either totally transparent or the same color as your solid-color background. By keeping this graphic as small as possible, you eliminate the beveled outline quickly.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="ClientPull"><FONT SIZE=5 COLOR=#FF0000>
Client-Pull</FONT></A></H2>
<P>
The <I>client-pull</I> principle was first introduced in chapter
1, &quot;Browser Identification,&quot; and has the browser load
a new page. There are several ways to implement client-pull. Two
ways are discussed here.
<H3><A NAME="HTMLBasedClientPull">
HTML-Based Client-Pull</A></H3>
<P>
Using the HTML <TT>&lt;META&gt;</TT> tag:
<BLOCKQUOTE>
<PRE>
&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;secs; URL=newURL&quot;&gt;
</PRE>
</BLOCKQUOTE>
<P>
You can cause the user's browser to &quot;pull&quot; a new document
from the server after a given period of time, as specified by
the <TT>secs</TT> parameter of the <TT>CONTENT</TT> attribute.
Extending this to graphic animation, you simply create a sequence
of HTML documents with the <TT>&lt;META&gt;</TT> tag of any given
document, specifying the URL of the next document in the sequence.
<P>
The client-pull system has some problems:
<UL>
<LI>Each &quot;pull&quot; forces a new page to load from the server.
In a framed site, this can be used to animate a small frame on
the page. This does not affect anything else, but you still must
contend with the additional overhead a complete page load entails:
the entire page and all objects and images it contains.
<LI>The resolution of the &quot;pull interval,&quot; which is
the time between page loads, is limited to <I>seconds</I>. You
can't have subsequent requests happen any faster than one second
apart. For certain types of animation, like advertising, this
is acceptable; however, for &quot;pseudo-movies,&quot; this may
be too slow.
</UL>
<P>
An alternative method for implementing client-pull is to switch
to client-side scripting.
<H3><A NAME="JavaScriptClientPull">
JavaScript Client-Pull</A></H3>
<P>
JavaScript provides a set of timer-control functions that allows
you to create and react to timers. This way, you can:
<BLOCKQUOTE>
Force new pages to load at faster intervals in the HTML-based
system.<BR>
Build dynamic URLs of the successive documents.
</BLOCKQUOTE>
<P>
Being able to generate URLs &quot;on-the-fly&quot; (dynamically)
gives you random pull capability, such as that used in advertising.
A Code fragment demonstrating random pull is shown in listing
7.1.
<HR>
<BLOCKQUOTE>
<B>Listing 7.1&nbsp;&nbsp;JavaScript-Based Random-Pull<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;
&lt;!--
...
urlList = new initArray();
urlList[1] = &quot;frame1.html&quot;;
...
urlList[5] = &quot;frame5.html&quot;;

setTimer(&quot;document.location.href = &quot; + urlList[random(5)], 10000);
// --&gt;
&lt;/SCRIPT&gt;
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Whether you use HTML-based or JavaScript-based client-pull, you're
still loading a complete HTML document from the server with all
the associated overhead, screen redrawing, and so on. If you're
looking for animations that are more subtle, you might want to
look at <I>animated GIFs</I>.
<H2><A NAME="AnimatedGIFs"><FONT SIZE=5 COLOR=#FF0000>
Animated GIFs</FONT></A></H2>
<P>
Both Netscape Navigator and Internet Explorer support the current
GIF standard (called <I>GIF89a</I>), as do most browsers. While
other browsers support one feature or another, Navigator 2.0 and
Explorer 3.0 (and later versions of both) also support the standard's
ability to store more than just a single image. Note that interlacing
and transparency are part of GIF89a. In fact, GIF89a also supports
storing <I>timing</I> data, so that the speed that successive
images display can be controlled. This makes it possible to create
&quot;flip-book-like&quot; animations that store as a single image
file and don't require helper applications or plug-ins to view.
<P>
Netscape added its own flavor to the standard by creating a <I>Netscape
Application Block</I> that when embedded within a GIF file, triggers
the image to loop from the PC's cache instead of having to be
reloaded from the server.
<P>
While other animation file types, such as QuickTime or .AVI, require
preexisting software (helper apps or plug-ins) to run, animated
GIFs are totally self-contained. The file downloads once and plays
from the computer's disk cache. From the perspective of HTML,
an animated GIF is no different from any other image. You simply
create an <TT>IMG</TT> tag; the tricky part is <I>creating</I>
the file itself.
<P>
The basic principle for creating an animated GIF is to:
<OL>
<LI>Create each separate image, or &quot;frame,&quot; in the sequence
as a separate graphic file.
<LI>Glue the individual frames together with control blocks between
each frame. These blocks instruct the browser how many 100ths
of a second to wait before loading the next frame. 
<LI>Add a final block that instructs the browser to start over
at the beginning in the case of a looping animation.
</OL>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Navigator doesn't handle the timing delay between frames the same way Internet Explorer does. While Internet Explorer's delay is tied to the system clock for a steady frame rate, Navigator's delay loop is tied to the browser's <I>event queue</I>. This<I> 
</I>also handles keyboard and mouse activity. You can test this by visiting a page that utilizes animated GIFs and by moving the mouse over the browser window while watching the animation. Under Navigator, you control the speed of the animation by varying 

the speed of the mouse, while Explorer always animates at a constant rate.
</BLOCKQUOTE>
<BLOCKQUOTE>
If you're trying to create smoothly timed animations, utilize a plug-in or client-side scripting. This is covered next.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The easiest way to create animated GIFs is to use one of several
shareware applications that do most of the work for you. Examples
are:
<BLOCKQUOTE>
<I>GIF Construction Set</I> (for Windows) by Alchemy Mindworks
<BR>
<I>GIFLoop</I> (for DOS) by Royal Frazier<BR>
WhirlGIF (for UNIX) by Kevin Kadow<BR>
GIFBuilder (for Macintosh) by Yves Piguet<BR>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><BLOCKQUOTE>
<B>NOTE</B>
</BLOCKQUOTE>
</TD>
</TR>
<TR><TD><BLOCKQUOTE>
These programs and links to others are found on the companion CD.  If you want to check out some online examples of animated GIFs in action, stop by the &quot;GIF89a Animation Gallery&quot; at <B><A 
HREF="http://trureality.com/anime.htm">http://trureality.com/anime.htm</A></B>.&nbsp;n
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
You can also specify the x and y coordinates of the upper-left
corner of each frame within the &quot;stage&quot; created by the
first image in the sequence. This way, if the change from frame
to frame is small, you can reduce the overall file size by having
each successive frame contain only the image area that changes.
<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><BLOCKQUOTE>
<B>CAUTION</B>
</BLOCKQUOTE>

</TD></TR>
<TR><TD><BLOCKQUOTE>
When creating animated GIFs or when using any type of multi-image animation, it's easy to construct image files or animation sequences that are almost as big as multimedia files (like .AVI or .MOV). Remember, the larger the file, the longer it takes your 
page to load.</BLOCKQUOTE>
<BLOCKQUOTE>
A good rule of thumb when gauging load time is to assume that the average Internet user connects through a 14.4K modem. This equals a <I>bandwidth, </I>or transmission rate, of about 1.7K per second-assuming a <I>perfect</I> condition. To give yourself 
some slack, figure that 1K of data takes 1 second to transmit. Using this rule, a 60K image takes about 60 seconds.
</BLOCKQUOTE>
<BLOCKQUOTE>
It can take <I>minutes</I> for someone to view your site because each component of a Web page adds to the transfer time. Text compresses somewhat and transfers faster, but it averages out over the page.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="DynamicIltIMGgtITagManipulation"><FONT SIZE=5 COLOR=#FF0000>
Dynamic <I>&lt;IMG&gt;</I> Tag Manipulation</FONT></A></H2>
<P>
With Navigator 3.0, JavaScript's control over the in-document
images (such as those defined by an <TT>&lt;IMG&gt;</TT> tag)
has been extended to permit images to be dynamically loaded <I>without</I>
requiring the entire page to be reloaded. With this new trick,
you can pull some interesting punches with your graphics-but first,
a little background on the new <TT>Image</TT> object.
<H3><A NAME="TheIImageIObject">
The <I>Image</I> Object</A></H3>
<P>
As with other JavaScript objects that provide &quot;wrappers&quot;
to HTML objects, the properties of an <TT>Image</TT> object reflect
the attributes of a corresponding <TT>&lt;IMG&gt;</TT> tag. Two
properties are of particular interest:
<BLOCKQUOTE>
<TT>src</TT>-reflects the <TT>SRC</TT> attribute and contains
the URL of the image that displays.<BR>
<TT>lowsrc</TT>-reflects the <TT>LOWSRC</TT> attribute.
</BLOCKQUOTE>
<P>
Other properties, such as <TT>width</TT> and <TT>height</TT>,
are <I>read-only</I> once the image displays, but <TT>src</TT>
and <TT>lowsrc</TT> can be changed even after the image is loaded.
Within JavaScript, changes can be made to a timer or mouse event
that reflect in the display image. To specify a new graphic for
a given <TT>Image</TT> object, simply change either the <TT>src</TT>
or <TT>lowsrc</TT> attribute:
<BLOCKQUOTE>
<PRE>
imageObject.src = &quot;newgraphic.gif&quot;;<BR>
</PRE>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
It was shown earlier in this chapter how to use the <TT>LOWSRC</TT> attribute to load a low-resolution graphic. This graphic quickly displays an image in place on the page before the high-resolution graphic associated with the <TT>SRC</TT> attribute 
retrieves from the server. The order of loading <TT>LOWSRC</TT> first and then <TT>SRC</TT> still applies with the <TT>Image</TT> object.
</BLOCKQUOTE>
<BLOCKQUOTE>
If you want to change the <TT>lowsrc</TT> attribute, you need to do it <I>before</I> you change the <TT>src</TT> attribute. You must change the <TT>src</TT> attribute as well for the graphic to actually be loaded. If <TT>lowsrc</TT> is changed but 
<TT>src</TT> remains the same, nothing happens.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Within the JavaScript hierarchy, all the <TT>Image</TT> objects
associated with <TT>&lt;IMG&gt;</TT> tags are stored within the
<TT>images[]</TT> array, a property of the <TT>document</TT> object.
With this in hand, loading a new image into an existing object
is simple:
<BLOCKQUOTE>
<PRE>
document.images[1].src = &quot;newgraphic.jpg&quot;;
</PRE>
</BLOCKQUOTE>
<P>
loads <TT>newgraphic.jpg</TT> into the second <TT>&lt;IMG&gt;</TT>
tag in the document.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
While user-defined arrays begin their indexing with <TT>1</TT>, the <TT>images[]</TT> array is built-in like the <TT>forms[]</TT> and <TT>frames[]</TT> arrays, and begins its indexing at <TT>0</TT> (zero). Therefore, the first <TT>&lt;IMG&gt;</TT> tag is 
referenced at:
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT>document.images[0]</TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="CachedImages">
Cached Images</A></H3>
<P>
While most <TT>Image</TT> objects in a document correspond to
an <TT>&lt;IMG&gt;</TT> tag, it is not a requirement. An additional
benefit of the <TT>Image</TT> object is that you can use the JavaScript
<TT>new</TT> operator to create objects <I>in memory</I>. Once
you create the object, load additional images <I>that aren't displayed</I>.
For example:
<BLOCKQUOTE>
<PRE>
memImage = new Image();
memImage.src = &quot;logo.gif&quot;;
</PRE>
</BLOCKQUOTE>
<P>
would create an <TT>Image</TT> object in memory and load the file
<TT>logo.gif </TT>from the server. The resulting object would
have the dimensions of the graphic. If you wished to stretch a
graphic to a specific size, specify the dimensions when you create
the object, as in:
<BLOCKQUOTE>
<PRE>
memImage = new Image(50, 100);
</PRE>
</BLOCKQUOTE>
<P>
This creates an image 50&#165;100 pixels in size. At this point,
any image file you load into the image resizes to the dimensions
of the object.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>NOTE</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Once created, the dimensions of an image cannot be changed. Note that you can change the <TT>src</TT> attribute and the associated image as often as you choose.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
This gives you the ability to &quot;cache&quot; images locally
on the user's machine to make the transition between images faster.
Even though cached objects aren't connected with <TT>&lt;IMG&gt;</TT>
tags, they still maintain all the properties of <TT>Image</TT>
objects.<BR>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR><TD><B>CAUTION</B></TD></TR>
<TR><TD>
<BLOCKQUOTE>
Remember that any image loaded, even for future display, must be pulled from the server; in the case of cached images, the cached copy is checked against the server copy to ensure that the most recent file is being used. This increases the time necessary 
to load all the parts of a particular page. Creating <TT>Image</TT> objects in memory and loading them &quot;behind the scenes&quot; helps to speed the visual display of a page. This is done by deferring additional image loading until after the page loads. 

Remember that there is still retrieval time for all of your images to come from the server.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
You can change the display image by setting the <TT>src</TT> and
<TT>lowsrc</TT> properties. Setting the <TT>src </TT>property
has the side-effect of starting to load the new URL into the image
area and aborting the transfer of any image data that is already
loading into the same area. If you're going to alter the <TT>lowsrc</TT>
property, you need to do so before setting the <TT>src </TT>property.
If the URL in the <TT>src</TT> property references an image that
is not the same size as the image cell it is loaded into, the
source image scales to fit.
<P>
The main use for an explicitly created Image object is to force
an image to retrieve from the server <I>before </I>it is actually
needed for display. That way, when a statement such as
<BLOCKQUOTE>
<PRE>
document.images[0].src = myImage.src
</PRE>
</BLOCKQUOTE>
<P>
executes, the image displays immediately because it is already
in memory. Use this capability to create smooth animations or
display one of three images based on some form input. The following
is a script fragment that takes advantage of this trick to create
&quot;live buttons&quot; that change their graphic when the mouse
passes over them (see listing 7.2). 
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 7.2&nbsp;&nbsp;Implementing &quot;Live&quot; Buttons</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<PRE>
&lt;SCRIPT LANGAUGE=&quot;JavaScript&quot;&gt;
&lt;!--
onImage = new Image();
onImage.src = &quot;over.gif&quot;;

offImage = new Image();
offImage.src = &quot;notOver.gif&quot;;

function goLive() {
   document.images[0].src = onImage.src;
   setTimer(&quot;document.images[0].src = offImage.src;&quot;, 5000);
}
// --&gt;
&lt;/SCRIPT&gt;
...
&lt;A HREF=&quot;nextPage.html&quot; ONMOUSEOVER=&quot;goLive()&quot;&gt;&lt;IMG
   SRC=&quot;notOver.gif&quot; BORDER=0&gt;&lt;/A&gt;
...
</PRE>
</BLOCKQUOTE>
<HR>
<P>
Because of the nature of the <TT>onMouseOver</TT> event, it's
necessary to set a timer to restore the &quot;off image&quot;
after a period of time.
<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>
From Here&#133;</FONT></A></H2>
<P>
With the tricks and techniques presented in this chapter, you
can add &quot;zing&quot; to your Web pages. For additional ideas
on how to utilize these methods or learn more about them, you
can check out:
<UL>
<LI><B><A HREF="http://members.aol.com/royalef/gifanim.htm">http://members.aol.com/royalef/gifanim.htm</A></B>, for a more
in-depth explanation of the mechanics behind animated GIFs.
<LI><A HREF="ch8.htm" >Chapter 8</A> &quot;Advertising with Billboards,&quot; to incorporate
these graphics animation tricks into on-site advertising.
<LI><A HREF="ch24.htm" >Chapter 24</A>, &quot;Designing an eZine,&quot; personal online
publishing for a publication framework that can easily support
image animation.
</UL>
<HR>

<CENTER><P><A HREF="ch6.htm"><IMG SRC="pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="#CONTENTS"><IMG SRC="cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="index.htm"><IMG SRC="hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<A HREF="ch8.htm"><IMG SRC="nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>
<HR WIDTH="100%"></P></CENTER>
</BODY>
</HTML>
