\chapter{Pseudocode Conventions}
\label{cha:pseudocode-convent}

Instead of showing code examples in an programming language, we'll be
using pseudocode to explain the algorithms in this book. This is keep
things as general as possible, and not force the reader into knowing a
specific programming language before reading this book.

Sample code in the programming language \C{}, however, is provided. It
can be found in the \path|/code| directory. But we will not disscuss
this code, however, but the pseudocode.

The pseudocode will try to kept as traditional as possible, but we'll
still need to establish several conventions for it:

\section{Typographical Conventions}

For showing keywords, \textbf{bold font} is used. Functions use
\textproc{Small Caps}, Variable names use an $italic$-like font.

\section{Boolean Operators}
\label{sec:boolean-operators}

For the boolean operators we'll be using the following
symbols:

\begin{description}
\item[$\NOT$] logical \textit{not}
\item[$\AND$] logical \textit{and}
\item[$\OR$] logical \textit{or}
\end{description}

\section{Bitwise Operators}
\label{sec:bitwise-operators}

We will also use the bitwise operators. If you haven't even heard of
them, look up them and study them on your own. I assumed from the
beginning of this book that such knowledge should be obvious to
you. We will be using the notation used in \C{} to represent them in
pseudocode:

\begin{description}
\item[$\BitNeg$] Bitwise \textit{NOT}
\item[$\BitAnd$] Bitwise \textit{AND}
\item[$\BitOr$] Bitwise \textit{OR}
\item[$\BitXor$] Bitwise \textit{XOR}
\item[$\ShiftLeft$] Left bit shift
\item[$\ShiftRight$] Right bit shift
\end{description}

Notice that we are using $\BitXor$ for representing bitwise
\textit{XOR} rather than the traditional \C{} notation. This is due to
the fact that we'd otherwise confuse it with logical and, $\AND$.

\section{Functions}
\label{sec:pseudocode}

We'll be dealing with files in these compression algorithms, so we'll
need to introduce several functions for dealing with them:

\begin{description}[font=\normalfont]
\item[\textproc{ReadByte}] It is assumed from the beginning of the
  algorithm that a file has already been opened for reading. This
  could be the file we're either trying to compress or
  decompress. This function reads a byte from that file.

\item[\Call{WriteByte}{$byte$}] At the beginning of every algorithm,
  we also assume that there is a file opened for output. This function
  writes a byte to that file.

\item[\textproc{EndOfFileReached}] \True{} if the end the file we're
  reading from have been reached.

\item[\Call{Read}{$size$}] Just being able to read a byte may not
  always be enough. We may want to read a number of a specific size
  from a file. We will do that with this function. This functions
  reads a number of the size $size$ \textit{bytes}(not bits) from a
  file.

\item[\Call{Seek}{$offset$}] Move from the beginning of the $offset$
  bytes forward in the file we're currently reading.


\end{description}

\section{Syntax}
\label{sec:other-conventions}

As a decently competent programmer, you should be familiar with most
of the control structures we'll be using. One control structure that
may be unfamiliar to you, is the custom control structure called
\algorithmicrepeat, which is demonstrated in algorithm
\ref{alg:repeat}.

\todo{Cover all the control structures?}

\begin{algorithm}[H]
  \caption{The repeat control structure.}
  \label{alg:repeat}
  \begin{algorithmic}[1]
    \Repeatn{$n$}
      \State $actions\ldots$ \Comment{Repeats $actions\ldots n$ times}
    \EndRepeatn
  \end{algorithmic}
\end{algorithm}

The start of a comment is indicated by the symbol \commentsymbol.

To assign the value $n$ to the variable $var$, the notation shown in
algorithm \ref{alg:assign} is used.

\begin{algorithm}[H]
  \caption{Assigning the value $n$ to $var$..}
  \label{alg:assign}
  \begin{algorithmic}[1]
    \Let{$var$}{$n$}
  \end{algorithmic}
\end{algorithm}

\section{An example}

In this brief section, we'll be showing how all of the algorithms will
be typeset in this book. We will use binary search as an example
algorithm. It is shown in algorithm \ref{alg:binary-search}.

\begin{algorithm}[H]
  \caption{Binary Search.}
  \label{alg:binary-search}
  \begin{algorithmic}[1]
    \Function{writeRunLengthPacket}{$list,length,x$}
      \Let{$min$}{$1$}
      \Let{$max$}{$length$}
      \Repeat
        \Let{$min$}{$\frac{min + max}{2}$}
        \If{$x > list[mid]$}
          \Let{$min$}{$mid + 1$}
        \Else
          \Let{$max$}{$mid - 1$}
        \EndIf
      \Until{$list[mid] = x \OR min > max$}
    \EndFunction
  \end{algorithmic}
\end{algorithm}