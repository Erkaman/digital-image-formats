\chapter{Pseudocode Conventions}
\label{cha:pseudocode-convent}

Instead of showing code examples in some random programming language,
we'll be using pseudocode to explain the algorithms in this book. This
will keep things as general as possible, and not force the reader into
knowing a specific programming language before reading this book.


The pseudocode will be kept as traditional as possible, but we'll
still need to establish several conventions for it, which is what
we're going to do for the rest of the chapter.

\section{Typographical Conventions}

\begin{description}
\item[Keywords] will use \textbf{bold} font.
\item[functions] will be signified by \textbf{uppercase}.
\item[variables] can noticed by their $cursive$ style.
\end{description}

\section{Boolean Operators}
\label{sec:boolean-operators}

To signify the boolean operators we'll be using the following
symbols:

\begin{description}
\item[$\NOT$] logical \textit{not}
\item[$\AND$] logical \textit{and}
\item[$\OR$] logical \textit{or}
\end{description}

Boolean truth is represented by \True{}, and falseness is represented by
\False{}.

\section{Bitwise Operators}
\label{sec:bitwise-operators}

If you are not familiar with bitwise operators, I highly recommend you
to look up them and study them on your own, because we are going to
use them a lot in this book. We will be using the notation used in \C
to represent them in pseudocode:

\begin{description}
\item[$\BitNeg$] Bitwise \textit{NOT}
\item[$\BitAnd$] Bitwise \textit{AND}
\item[$\BitOr$] Bitwise \textit{OR}
\item[$\BitXor$] Bitwise \textit{XOR}
\item[$\ShiftLeft$] Left bit shift
\item[$\ShiftRight$] Right bit shift
\end{description}

Notice that we are using $\BitXor$ for representing bitwise
\textit{XOR} rather than the traditional \C notation. This is due to
the fact that we'd otherwise confuse it with logical and, $\AND$.

\section{Functions}
\label{sec:pseudocode}

We'll be dealing with files in many of these algorithms, so we'll need
to introduce several functions for handling file operations.

\begin{description}[font=\normalfont]
\item[\textproc{ReadByte}] It is assumed from the beginning of the
  algorithm that a file has already been opened for reading. This
  function reads a byte from that file.

\item[\Call{WriteByte}{$byte$}] At the beginning of every algorithm,
  we also assume that there is a file opened for output. This function
  writes a byte to that file.

\item[\textproc{EndOfFileReached}] \True{} if the end the file we're
  reading from have been reached.

\item[\Call{Read}{$size$}] Just being able to read a byte may not
  always be enough. We may want to read a number of a specific size
  from a file. We will do that with this function. This functions
  reads a number of the size $size$ \textit{bytes}(not bits) from a
  file.

\item[\Call{Seek}{$offset,origin$}] Move the from current position in
  the file offset bytes forward. The current position in the file is
  specified by the argument $origin$. If it is $START$, we move from the
  beginning of the file, if it is $END$ we move from the end of the
  file, and if it is $CURRENT$ we move from the current position in
  the file.

\end{description}

\section{Syntax}

As a decently competent programmer, you should be familiar with most
of the control structures we'll be using. But one control structure
that will be used that is probably unfamiliar to you is the custom
control structure called \algorithmicrepeat\index{Repeat Control
  Structure}, which is demonstrated in algorithm \ref{alg:repeat}.

\begin{algorithm}[H]
  \caption{The repeat control structure.}
  \label{alg:repeat}
  \begin{algorithmic}[1]
    \Repeatn{$n$}
      \State $actions$ \Comment{$actions$ are repeated $n$ times.}
    \EndRepeatn
  \end{algorithmic}
\end{algorithm}

and by the way, The start of a comment is indicated by the symbol \commentsymbol.

To assign the value $n$ to the variable $var$, the notation shown in
algorithm \ref{alg:assign} is used.

\begin{algorithm}[H]
  \caption{Assigning the value $n$ to $var$..}
  \label{alg:assign}
  \begin{algorithmic}[1]
    \Let{$var$}{$n$}
  \end{algorithmic}
\end{algorithm}