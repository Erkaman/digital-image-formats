\begin{comment}
  \bibliography{project.bib}
\end{comment}

% png iso spec?
% http://www.y-adagio.com/public/confs/itsig/rep_itsgxml4/docs/html15948/C029581e%20HTML/png-fdis-png-screen.htm

% http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/PNG.html
\chapter{Portable Network Graphics}
\label{cha:png}

\newcommand{\chnk}[1]{``#1''}

\section{History}

As explained in section \ref{sec:gif-history}, the creation of the PNG
format was was primarily motivated by the patents encumbering the
already popular GIF format. To solve this problem, a bunch of
developers in the graphics developer community decided to cooperate on
creating a new format. \dt{1}{7}{1996}, version 1.0 of the PNG
specification was released. Then version 1.1 was released on new years
eve of 1998. And the latest version of the PNG specification is
version 1.2, which was released in August 1999. After this it was
finally standardized by ISO as ISO/IEC standard 15948:2004
\cite{roelofs09:_histor_portab_networ_graph_png_format,roelofs99:_png,roelofs:_portab_networ_graph_main}.

What follows is a technical description of the PNG format. It is based
on the references
\cite{boutel:_png_portab_networ_graph_specif_version12,roelofs99:_png,boutel:_png_portab_networ_graph_specif_version11}.

  \cite{sivonen:_sad_story_png_gamma_correc}

\section{The Buildings Blocks of the format}

\subsection{Chunks}

PNG images are fundamentally built up of chunks. The structure of the
chunk is shown in figure \ref{fig:png-chunk}. It consists of four so
called fields. Let us desribe them, one after one:

\subsubsection*{Length (4 Bytes)}

This 32-bit number is used to store the byte length of the data
field.

\todo{mention that it's max value is $2^{31} -1$, rather than $2^{32}
  -1$}



\subsubsection*{Chunk Type (4 Bytes)}

This field stores 4 bytes that are used to store the type name of the
chunk. Only the ASCII letters in the ranges A--Z and a--z are
acceptable values of these bytes. So \chnk{abcd} is an acceptable
chunk type while \chnk{a:e;} is not.

There is a convention used in the naming of chunks. If the first
letters in the type name of a chunk is uppercase, it is a
\textit{critical} chunk. If the critical chunk is found in a PNG
image, then it \textit{must} be loaded for the image to be
successfully displayed.  if such a chunk is not loaded, the program
will not have enough information to render the image. Critical chunks
and their inner workings will for this reason be the main topic of
this chapter.

If on the other hand the first letter of the chunk type name is
lowercase, then that means that the chunk is \textit{ancillary}. These
chunks do not need to be loaded in order to successfully render the
image. These can contain all kinds of data, like the creation date of
the image or a textual comment. Since much of the data stored in
ancillary chunks are things that we discussed in chapter \ref{cha:gif}
and \ref{cha:tga}, we will not discuss these chunks are in depth as
the critical chunks.

\todo{explain better why we will cover the ancillary chunks as in
  depth.}

\subsubsection*{Data (Variable)}

In this field the actual data of the chunk is stored. The length of
this field was specified by the earlier length field.

\subsubsection*{CRC (4 Byte)}

This is a CRC that is used to validate the data in the chunk
field. The CRC algorithm used is algorithm ??, which we discussed in
chapter ??. The CRC is calculated using the chunk type data
\textit{and} the chunk data. If the computed CRC doesn't match the CRC
in this field, then the data in the chunk is corrupted, and you should
stop reading the PNG image and report an error message to the user.

\todo{reference the CRC-32 algorithm properly}

\begin{figure}
  \centering
  \inputtikz{png_chunk.tex}
  \caption{The PNG chunk datatype}
  \label{fig:png-chunk}
\end{figure}

\subsection{PNG Signature}

Only chunks can be found in a PNG image with one exception: the PNG
signature. The PNG signature is 8 bytes that are \textit{always} found
in the beginning of a legit PNG image. These bytes are $137 80 78 71
13 10 26 10$. They were all chosen to detect certain kinds of errors
that occur when transmitting a PNG file over a network.

The first bit is $137$. In binary this number is $1000\ 1001$. The key
part to notice is that this is a non-ASCII character, because since
the 7:th bit toggled it will always have a value $\ge 128$. When data
is tranmitted as ASCII-text over a network, the 7:th bit tends to be
thrown away, as it is for example done in STMP \cite{rfc5321}. STMP is
the Internet protocol used to transfer emails. To transmit non-ASCII
binary, like image data, data one should instead use the MIME
protocol, which is an extension to the STMP protocol.

So to summarize, the main purpose of the first bit is to detect
whether an image has accidentally been transmitted as ASCII text. If
this byte doesn't have its proper value, then the image has been
corrupted. Then also the bytes whose values are $\ge 128$ in the image
data will also be corrupted, so there's little to no point in the
decoder trying to open the corrupted image.

The bytes $80 78 71$ are the ASCII values for the string PNG, so they
could simply be seen as the magic numbers for the PNG format.

The following two bytes are $13 10$. This is a windows style newline,
CRLF, as discussed section in \ref{cha:pseudocode-convent}. If a PNG
file is accidentally transferred as text, there is another thing that
may corrupt the file: line ending conversions. When, for example, you
are transmitting a file from a window based operating system to a
UNIX-based operating system, there is a chance that the proram doing
the transmission may convert the windows-style line-endings to their
Unix equivalents, LF. But for a binary image file this behavior is
clearly undesirable, and is very likely to end up corrupting the image
data. To detect such errors, these two bytes are used.

The following byte $26$ is a bit peculiar in that it doesn't even in
verifying the correctness of the data. In the operating system DOS,
this is known as the end-of-file character. If such a character is
found while printing the contents of a file in DOS, then the printing
of the file stops. So thanks to this, you could only see the first few
bytes and verify that the file is a PNG file without seeing all the
garbage. \todo{clarify:
  %http://www.libpng.org/pub/png/book/chapter08.html#png.ch08.div.2
}

The last byte $10$ is the newline character in UNIX-based operating
systems, LF. So this is yet another byte that is used to verify that
the image was not transferred as text. This byte is used to verify
that an image transferred from a UNIX-based operating system to a
windows based operating system is not transferred as ASCII text.

\section{Critical Chunks}

Following the PNG signature a sequence of chunks. Most kinds of chunks
can simply be ignored, but the critical ones cannot for an image to be
properly rendered. Let us discuss the critical chunks, one after one.

\subsection{IHDR -- Image Header}

The image header of the PNG format, the \chnk{IHDR} chunk, is by the
PNG specification guaranteed to always occur first in a PNG file,
after the PNG signature. It contains data that is absolutely necessary
for loading the image data.

\subsubsection*{Width (4 Bytes)}
\subsubsection*{Height (4 Bytes)}

These two consecutive fields contains the size of the image. Since
they are stored in two 32-bit numbers each, this means that the PNG
format allows for quite huge images.

\subsubsection*{Bit Depth (1 Byte)}

In the bit depth the size of each channel in the color storage model
used is stored. Let $b$ be the value of this field. If grayscale color
is used, then $b$ of the color depth(the size of each pixel). If on
the other hand RGB color is used, then the color depth is $3 \cdot
b$. This makes sense, because the value of $b$ is the size of each
channel, \textit{not} the color depth itself. The PNG format also
allows for storing grayscale color with an alpha channel. In that case
the color depth will be $2 \cdot b$. And similarly, for RGBA the color
depth will be $4 \cdot b$. And if a color palette is used, the color
depth of the indexes stored in the image data will be $b$. However,
note the only the values 1, 2, 4, 8 and 16 are allowed values for this
field. This is mainly to simplify the job of the programmers using the
PNG format.

\subsubsection*{Color Type (1 Byte)}

The PNG format allows five different color storage models. The color
storage model used varies depending on this value, as is shown in
table \ref{tab:png-color-type}.

\begin{table}
  \centering
  \begin{tabular}{l l}
    \toprule
    Color Type & Description \\
    \midrule
    0 & Grayscale color \\
    2 & Truecolor, meaning that RGB is used \\
    3 & Indexed color, meaning that a color palette is used \\
    4 & Grayscale with an alpha channel \\
    6 & Truecolor with alpha, meaning that RGBA is used \\
    \bottomrule
  \end{tabular}
  \caption{The different color types of the PNG format}
  \label{tab:png-color-type}
\end{table}

As you can from this field and the former, the PNG is very flexible
and allows for a multitude of different ways of storing
color. However, the simplify things for programmers, not all possible
bit depths can be used with all color types. The allowed color depths
are shown in table \ref{tab:png-color-type}.

\begin{table}
  \centering

  \newcommand{\invalid}{\cellcolor{gray}}

  \begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
    \multirow{2}{*}{Color Type} & \multirow{2}{*}{Channels} & \multicolumn{5}{c|}{Color Depth} \\

  \cline{3-7}

    & & 1 & 2 & 4 & 8 & 16 \\

    \hline
    Indexed & 1 & 1 & 2 & 4 & 8 & \invalid \\ \hline
    Grayscale & 1 & 1 & 2 & 4 & 8 & 16  \\ \hline
    Grayscale and alpha & 2 & \invalid& \invalid & \invalid & 16 & 32  \\ \hline
    Truecolor & 3 & \invalid & \invalid & \invalid & 24 & 48  \\ \hline
    Truecolor and alpha & 4 & \invalid & \invalid & \invalid & 32 & 64  \\ \hline

    \hline

  \end{tabular}
  \caption{The allowed color depths for the PNG format.}
  \label{tab:png-color-depths}
\end{table}

\subsubsection*{Compression method (1 Byte)}

This field is used to indicate the compression method used in the
image data. But the only value defined for this field by the PNG
specification is $0$, which means that ZLIB deflate compression is
used.

\subsubsection*{Filter Method (1 Byte)}

PNG also allows certain filter to be applied to the image data. These
filters basically make the data compress better. Only the value $0$ is
defined for this field, and this means that the four default filters
are used to perform the filtering. We'll discuss the filter in section
??.  \todo{add reference to the section covering the filters}

\subsubsection*{Interlace Method (1 Byte)}

If this field is $0$, then no interlacing is used in the image data; if it
is $1$, then the image data is interlaced.

The PNG format supports an interlacing method known Adam7. This method
of interlacing is significantly more complex than that if GIF's, and
is something that we will discuss the very much in depth in section
??. \todo{add references}.

\subsection{PLTE -- Image Palette}

\subsection{IDAT -- Image Data}

\subsection{IEND -- Image Trailer}

\section{Color Data Storage}

\subsection{Uninterlaced Color Data}

\subsection{Interlaced Color Data}

\section{Ancillary Chunks of interests }

% mention private chunks like imagemagick's vpag

% quickly summarize the ones that won't get in depth coverage.