\begin{comment}
  \bibliography{project.bib}
\end{comment}

\chapter{Compression techniques}
\label{cha:digital-image}

\begin{refsection}

\section{Some terminology}
\label{sec:some-terminology}

Coding a data into another form is often referred to as
\textbf{encoding} \index{encoding}. Converting that encoded data back
into its orginal form is called \textbf{decoding}
\index{decoding}. \todo{Need sources on these two terms.}. In the
circumstanes of compression techniques, encoding is also often
referred to as \textbf{compression} \index{compression}, and decoding as
\textbf{decompression} \index{decompression} or \textbf{uncompression} \index{uncompression}

% http://www.digitizationguidelines.gov/term.php?term=encoder

\section{Pseudocode}
\label{sec:pseudocode}

We will be using several functions in the pseudocode.

\textproc{Read} reads a byte from a opened file.

\textproc{EndOfFileReached} true of the end the file have been
reached.

\textproc{Write} Writes a byte to a opened file.

\textproc{MaxValue(v)} returns the max value of the type of
\textproc{v}.

We will also a custom control structure, repeat:

\begin{algorithm}[h]
  \caption{The repeat control structure.}
  \label{alg:repeat}
  \begin{algorithmic}[1]
    \Repeat{$n$}
      \State $actions...$ \Comment{Repeats $actions...$ $n$ times} %
    \EndRepeat
  \end{algorithmic}
\end{algorithm}

\section{Run Length Encoding}
\label{sec:rle}

\subsection{Most simple version}
\label{sec:most-simple-version}

One the most simple compression algorithms is known as Run Length
Encoding \index{Run Length Encoding}(RLE
\index{RLE}). \cite{nagarajan11:_enhan_approac_run_lengt_encod_schem}
The basic working of the algorithm, is that sequences of consecutive
data is stored count and a single value rather than the entire
run.

But what does that mean? Let us consider the string

\begin{indentpar}
  WWWWAAAACCCCCCQ
\end{indentpar}

When running the RLE encoding algorithm on this string, it is
compressed like this:

\begin{indentpar}
  4W4A6C1Q
\end{indentpar}

So all the RLE encoding algorithm does is encode long consequtive runs
of the same value as a count and a single data value. But however, the
same thing is also done for single runs, meaning that the algorithm
can potentially explode the size of the original data, rather than
compress it. Consider, for example, the string:

\begin{indentpar}
  eric
\end{indentpar}

this will actually get ``compressed'' down to

\begin{indentpar}
  1e1r1i1c
\end{indentpar}

So the size actually doubled for this kind of data! So for very data
with very varying values, like photos and books, this algorithm will
do just horrible. But in data in which the values are not varied much
at all, like line art and simple vector graphics, even for such a
naive algorithm it will do quite good.

It's very easy to see that this is trivial to implement in code Let us
first consider the compression algorithm:

\newcommand{\eof}{\ensuremath{\VoidCall{EndOfFileReached}}}
\newcommand{\neof}{\ensuremath{\NOT \VoidCall{EndOfFileReached}}}

\begin{algorithm}[h]
  \caption{Encoding a file using RLE.}
  \label{alg:rle-enc}
  \begin{algorithmic}[1]
    \Let{$length$}{$1$}
    \Let{$passedFirstCharacter$}{\False}
    \Let{$c_2$}{ \Call{Read}{}}
    \While{\neof}
      \If{$passedFirstCharacter$}
        \If{$c_2 = c_1 \AND length < \Call{MaxValue}{length}$}
          \Let{$length$}{$1 + length$}
        \Else
          \State \Call{Write}{$length$}
          \State \Call{Write}{$c_1$}
          \Let{$length$}{$1$}
        \EndIf
      \EndIf
      \Let{$passedFirstCharacter$}{\True} %
      \Let{$c_1$}{$c_2$}
      \Let{$c_2$}{ \Call{Read}{}}
    \EndWhile
    \If{$passedFirstCharacter$} \Comment{Write the last bytes.}
      \State \Call{Write}{$length$}
      \State \Call{Write}{$c_1$}
    \EndIf
  \end{algorithmic}
\end{algorithm}

The RLE decoding is very simple:

\begin{algorithm}[h]
  \caption{Decoding a RLE encoded file.}
  \label{alg:rle-dec}
  \begin{algorithmic}[1]

    \While{\neof}
      \Let{$length$}{\Call{Read}{}}
      \Let{$c$}{\Call{Read}{}}

      \If{\eof}
        \Break
      \EndIf

      \Repeat{$length$}
        \State \Call{Write}{$b$}
      \EndRepeat
    \EndWhile
  \end{algorithmic}
\end{algorithm}

All we're really doing here is reading packet length and the packet
data and then outputting that data length times to a file.

\subsection{Packets version}
\label{sec:packets-version}

packet. \cite{91:_truev_tga_file_format_specif}

\FloatBarrier

\printbibliography[heading=subbibliography]

\end{refsection}