\begin{comment}
  \bibliography{project.bib}
\end{comment}

\chapter{Compression techniques}
\label{cha:digital-image}

\begin{refsection}

\section{RLE}
\label{sec:rle}

One the most simple compression algorithms is known as Run Length
Encoding \index{Run Length Encoding}(RLE
\index{RLE}). \cite{nagarajan11:_enhan_approac_run_lengt_encod_schem}
It is most easily explained by example.

Let us consider the string

\begin{indentpar}
  WWWWAAAACCCCCCQ
\end{indentpar}

When running the RLE encoding on this string, we get this as a result:

\begin{indentpar}
  4W4A6C1Q
\end{indentpar}

You saw what just happened? Every letter was given a number indicating
the number is was repeated. Even if the letter was only repeated it
would still be prefixed by a $1$. And this is problematic indeed. For
example consider

\begin{indentpar}
  eric
\end{indentpar}

this will actually ``compress'' to

\begin{indentpar}
  1e1r1i1c
\end{indentpar}

which is just horrible, the size actually doubled this time! So for
very data with very varying values this algorithm will do just
horrible. But in data in which the values are not varied much at all,
like lineart and simple vector graphics, even such a naive algorithm
will do quite good.

So how could it be implemented? Let's first consider the compression algorithm:

%\newcommand{\readb}{\Let{$b$}{ \Call{Read}{}}}

\begin{algorithm}
  \caption{Decoding a RLE encoded file.}
  \label{alg:rle-dec}
  \begin{algorithmic}[1]
    \Let{$length$}{$-1$} \Comment{The number of bytes to uncomppress.}

    \Let{$b$}{ \Call{Read}{}} \Comment{Reads the next byte.}
    \While{$b\not=EOF$} \Comment{While the end the file hasn't yet
      been reached.}
      \If{$length = -1$}
        \Let{$length$}{$b$}
      \Else
        \Repeat{$length$}
          \State \Call{Write}{$b$}
        \EndRepeat
        \Let{$length$}{$-1$}
      \EndIf
      \Let{$b$}{\Call{Read}{}}
    \EndWhile
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Encoding a file using RLE.}
  \label{alg:rle-enc}
  \begin{algorithmic}[1]
    \Let{$length$}{$1$} \Comment{The number of bytes to write to the
      file compressed.}
    \Let{$passedFirstCharacter$}{\False}
    \Let{$c_2$}{ \Call{Read}{}}
    \While{$c_2\not=EOF$} \Comment{While the end the file hasn't yet
      been reached.}
      \If{$passedFirstCharacter$}
        \If{$c_2 = c_1 \AND length < \Call{MaxValue}{length}$}
          \Let{$length$}{$1 + length$}
        \Else
          \State \Call{Write}{$length$}
          \State \Call{Write}{$c_1$}
          \Let{$length$}{$1$}
        \EndIf
      \EndIf
      \Let{$passedFirstCharacter$}{\True} %
      \Let{$c_1$}{$c_2$}
      \Let{$c_2$}{ \Call{Read}{}}
    \EndWhile
    \Comment{Write the last bytes.}
    \If{$passedFirstCharacter$}
      \State \Call{Write}{$length$}
      \State \Call{Write}{$c_1$}
    \EndIf
  \end{algorithmic}
\end{algorithm}

\printbibliography[heading=subbibliography]

\end{refsection}

