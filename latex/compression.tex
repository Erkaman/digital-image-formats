\begin{comment}
  \bibliography{project.bib}
\end{comment}

\chapter{Compression techniques}
\label{cha:digital-image}

\begin{refsection}

\section{Some terminology}
\label{sec:some-terminology}

Coding a data into another form is often referred to as
\textbf{encoding} \index{encoding}. Converting that encoded data back
into its orginal form is called \textbf{decoding}
\index{decoding}. \todo{Need sources on these two terms.}. In the
circumstanes of compression techniques, encoding is also often
referred to as \textbf{compression} \index{compression}, and decoding as
\textbf{decompression} \index{decompression} or \textbf{uncompression} \index{uncompression}

% http://www.digitizationguidelines.gov/term.php?term=encoder

\section{Pseudocode}
\label{sec:pseudocode}

We will be using several functions in the pseudocode.

\textproc{Read} reads a byte from a opened file. If the end of the
file has been reached, the constant $EOF$ is returned.

\textproc{Write} Writes a byte to a opened file.

\textproc{MaxValue(v)} returns the max value of the type of
\textproc{v}.

We will also a custom control structure, repeat:

\begin{algorithm}[h]
  \caption{The repeat control structure.}
  \label{alg:repeat}
  \begin{algorithmic}[1]
    \Repeat{$n$}
      \State $actions...$ \Comment{Repeats $actions...$ $n$ times} %
    \EndRepeat
  \end{algorithmic}
\end{algorithm}

\section{RLE}
\label{sec:rle}

\subsection{Most simple version}
\label{sec:most-simple-version}

One the most simple compression algorithms is known as Run Length
Encoding \index{Run Length Encoding}(RLE
\index{RLE}). \cite{nagarajan11:_enhan_approac_run_lengt_encod_schem}
The basic working of the algorithm, is that sequences of consecutive
data is stored count and a single value rather than the entire
run.

But what does that mean? Let us consider the string

\begin{indentpar}
  WWWWAAAACCCCCCQ
\end{indentpar}

When running the RLE encoding algorithm on this string, it is
compressed like this:

\begin{indentpar}
  4W4A6C1Q
\end{indentpar}

So all the RLE encoding algorithm does is encode long consequtive runs
of the same value as a count and a single data value. But however, the
same thing is also done for single runs, meaning that the algorithm
can potentially explode the size of the original data, rather than
compress it. Consider, for example, the string:

\begin{indentpar}
  eric
\end{indentpar}

this will actually get ``compressed'' down to

\begin{indentpar}
  1e1r1i1c
\end{indentpar}

So the size actually doubled for this kind of data! So for very data
with very varying values, like photos and books, this algorithm will
do just horrible. But in data in which the values are not varied much
at all, like line art and simple vector graphics, even for such a
naive algorithm it will do quite good.

So how could it be implemented? Let's first consider the compression algorithm:

%\newcommand{\readb}{\Let{$b$}{ \Call{Read}{}}}

\begin{algorithm}[h]
  \caption{Encoding a file using RLE.}
  \label{alg:rle-enc}
  \begin{algorithmic}[1]
    \Let{$length$}{$1$} \Comment{The number of bytes to write to the
      file compressed.}
    \Let{$passedFirstCharacter$}{\False}
    \Let{$c_2$}{ \Call{Read}{}}
    \While{$c_2\not=EOF$} \Comment{While the end the file hasn't yet
      been reached.}
      \If{$passedFirstCharacter$}
        \If{$c_2 = c_1 \AND length < \Call{MaxValue}{length}$}
          \Let{$length$}{$1 + length$}
        \Else
          \State \Call{Write}{$length$}
          \State \Call{Write}{$c_1$}
          \Let{$length$}{$1$}
        \EndIf
      \EndIf
      \Let{$passedFirstCharacter$}{\True} %
      \Let{$c_1$}{$c_2$}
      \Let{$c_2$}{ \Call{Read}{}}
    \EndWhile
    \Comment{Write the last bytes.}
    \If{$passedFirstCharacter$}
      \State \Call{Write}{$length$}
      \State \Call{Write}{$c_1$}
    \EndIf
  \end{algorithmic}
\end{algorithm}

And here's the decoding algorithm:

\begin{algorithm}[h]
  \caption{Decoding a RLE encoded file.}
  \label{alg:rle-dec}
  \begin{algorithmic}[1]

    \While{$\NOT \VoidCall{EndOfFileReached}$}
      \Let{$length$}{\Call{Read}{}}
      \Let{$c$}{\Call{Read}{}}

      \If{$\VoidCall{EndOfFileReached}$}
        \Break
      \EndIf

      \Repeat{$length$}
        \State \Call{Write}{$b$}
      \EndRepeat
    \EndWhile
  \end{algorithmic}
\end{algorithm}

\subsection{Packets version}
\label{sec:packets-version}

packet. \cite{91:_truev_tga_file_format_specif}

\FloatBarrier

\printbibliography[heading=subbibliography]

\end{refsection}