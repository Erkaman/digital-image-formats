\begin{comment}
  \bibliography{project.bib}
\end{comment}

\chapter{DEFLATE}
\label{cha:deflate}

The following description of the DEFLATE algorithm is based on \cite{pkware:_appnot,deutsch96:_deflat_compr_data_format_specif,Salomon:2004:DCC,feldspar:_explan_deflat_algor}

\section{History}

The DEFLATE algorithm was devised by Phil Katz for usage in the Zip
format he had also invented and it was first formally defined in
\cite{deutsch96:_deflat_compr_data_format_specif}.

\section{Algorithm}

There is a general format of DEFLATE compressed data, but we will not
yet describe that because we first of all need a good view of the
algorithm operates to begin with.

\subsection{Length and Distance Codes}

DEFLATE compressed data on the basic level consists of two datatypes:
literal bytes and length-distance pairs, meaning that it uses a LZ77
variation to do compression. It in other words uses a system very
similar to that of LZSS, which uses unmatched tokens and matched
tokens.

the alphabet 0--255 is used to encode literal bytes, which are just
like unmatched tokens for which for no match was found for in the LZ77
window. The special value $256$ is used to indicate the end of the
compressed data. Note that this value is part of the same alphabet as
the literal bytes. Also part of the same alphabet are the length
codes. They can be found in the range 257--285, and they are used to
indicate the length of the LZ77 matched strings. The entire alphabet
consists of the values 0--285 and this entire alphabet will get
Huffman codes in the later parts of the algorithm, which we will get
to soon.

The length codes are a bit tricky to use, though. Please observe table
\ref{tab:deflate-length-codes}. This table means that if a code of
$257$ then that means that this code in reality represents a length of
$3$, and in the same way a code of $262$ represents a length of
$8$. But how should a code like $265$ be parsed? First, we will remark
the minimum length this can represent is $11$. This code is then
followed by an extra bit, as indicated by the table. The extra bit is
added to minimum code length to get the true code length. In other
words, a code of $265$ followed by the extra bit $1$ will represent
the code length $12$, but had it on the other hand been followed by
the single bit $0$, then it would have represented the code length
$11$. In the same way, a length of $95$ is indicated by the length
code $278$ followed by the 4-bit number $12$.

\begin{table}

  \newcommand*\hdr{Code &  \parbox[t]{5mm}{Extra\\bits} & Lengths}
  \begin{minipage}[t]{0.32\textwidth}
    \centering
    \begin{tabular}{lll}
      \toprule
      \hdr{} \\
      \midrule
      257 & 0 & 3 \\
      258 & 0 & 4 \\
      259 & 0 & 5 \\
      260 & 0 & 6\\
      261 & 0 & 7 \\
      262 & 0 & 8 \\
      263 & 0 & 9 \\
      264 & 0 & 10 \\
      265 & 1 & 11--12 \\
      266 & 1 & 13--14 \\
      \bottomrule
    \end{tabular}
  \end{minipage}
  \begin{minipage}[t]{0.32\textwidth}
    \centering
    \begin{tabular}{lll}
      \toprule
      \hdr{} \\
      \midrule
      267 & 1 & 15--16 \\
      268 & 1 & 17--18 \\
      269 & 2 & 19--22 \\
      270 & 2 & 23--26\\
      271 & 2 & 27--30 \\
      272 & 2 & 31--34 \\
      273 & 0 & 33--42 \\
      274 & 3 & 43--50 \\
      275 & 3 & 51--58 \\
      276 & 3 & 59--66 \\
      \bottomrule
    \end{tabular}
  \end{minipage}
  \begin{minipage}[t]{0.32\textwidth}
    \centering
    \begin{tabular}{lll}
      \toprule
      \hdr{} \\
      \midrule
      277 & 4 & 67-82 \\
      278 & 4 & 83-98 \\
      279 & 4 & 99-114 \\
      280 & 4 & 115-130\\
      281 & 5 & 131-162 \\
      282 & 5 & 163-194 \\
      283 & 5 & 195-226 \\
      284 & 5 & 227-257 \\
      285 & 0 & 258 \\
      % dirty hack, but it works.
      & & \\
      \bottomrule
    \end{tabular}
  \end{minipage}

  \caption{DEFLATE length codes}
  \label{tab:deflate-length-codes}
\end{table}

Following a length code and its accompanying extra bits is always a
distance code. Offsets are termed distances in the DEFLATE
literature. The distance codes are drawn from the alphabet 0--29 and
they are stored in very much the same way as length codes, as is shown
in table \ref{tab:deflate-distance-codes}. So distance of $30000$ will
be represented by a length code 29 followed by the 13-bit value
5423, since

\begin{equation*}
  24577 + 5423 = 30000
\end{equation*}

\begin{table}

  \newcommand*\hdr{Code &  \parbox[t]{5mm}{Extra\\bits} & Distances}
  \begin{minipage}[t]{0.32\textwidth}
    \centering
    \begin{tabular}{lll}
      \toprule
      \hdr{} \\
      \midrule
      0 & 0 & 1 \\
      1 & 0 & 2 \\
      2 & 0 & 3 \\
      3 & 0 & 4\\
      4 & 1 & 5--6\\
      5 & 1 & 7--8 \\
      6 & 2 & 9--12 \\
      7 & 2 & 13--16 \\
      8 & 3 & 17--24 \\
      9 & 3 & 25--32 \\
      \bottomrule
    \end{tabular}
  \end{minipage}
  \begin{minipage}[t]{0.32\textwidth}
    \centering
    \begin{tabular}{lll}
      \toprule
      \hdr{} \\
      \midrule
      10 & 4 & 33--48 \\
      11 & 4 & 49--64 \\
      12 & 5 & 65--96 \\
      13 & 5 & 97--128 \\
      14 & 6 & 129--192 \\
      15 & 6 & 193--256 \\
      16 & 7 & 257--384 \\
      17 & 7 & 385--512 \\
      18 & 8 & 512--768 \\
      19 & 8 & 769--1024 \\
      \bottomrule
    \end{tabular}
  \end{minipage}
  \begin{minipage}[t]{0.32\textwidth}
    \centering
    \begin{tabular}{lll}
      \toprule
      \hdr{} \\
      \midrule
      20 & 9 & 1025--1536  \\
      21 & 9 & 1537--2048  \\
      22 & 10 & 2049--3072  \\
      23 & 10 & 3073--4096  \\
      24 & 11 & 4097--6144  \\
      25 & 11 & 6145--8192  \\
      26 & 12 & 8193--12288  \\
      27 & 12 & 12289--16384  \\
      28 & 13 & 17385--24576  \\
      29 & 13 & 24577--32768  \\
      \bottomrule
    \end{tabular}
  \end{minipage}

  \caption{DEFLATE distance codes}
  \label{tab:deflate-distance-codes}
\end{table}

\section{Fixed Huffman Codes}

All the codes in the distance, litteral and length alphabets will be
encoded in the compressed data using Huffman codes.

\section{Dynamic Huffman Codes}

\section{Storing the Huffman Codes}

