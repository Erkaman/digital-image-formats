\begin{comment}
  \bibliography{project.bib}
\end{comment}

\chapter{Graphics Interchange Format}
\label{cha:gif}

The topic of this chapter will be the image format known as Graphics
Interchange Format. We'll first discuss the rather complicated legal
history that the format has and then we'll discuss the inner workings
of the format. Since many of the features of the TGA format can also
be found in the GIF format, we won't be as detailed as we were in
chapter \ref{cha:tga} when we are describing all the features of the
GIF format.

\section{History}
\label{sec:gif-history}

The information in the following section is based on the references
\cite{welch85:_u,roelofs09:_histor_portab_networ_graph_png_format,battilana:_gif_contr,caie:_sad,roelofs99:_png}.

% http://netghost.narod.ru/gff/graphics/book.htm

\subsection{Troublesome Patents}

\newcommand{\compus}{CompuServe\xspace}

In 1987, a company named \compus started designing a new image format
called \textit{Graphics Interchange Format}, abbreviated GIF. \compus
chose to use a small variation of LZW for compressing color data in
the GIF format.

But at the same time, \compus and the rest of the world had no idea
that Unisys, the company that Terry Welch was employed by at the time
he invented LZW, was pursuing a patent for the LZW compression
algorithm. And once Unisys had gained the patent and informed the rest
of the world of this, the GIF format had already been released by
\compus.

But it wasn't until 1993 that Unisys seriously started pursuing
companies that were selling software using the LZW algorithm. And one
of those companies that Unisys started attacking because of this was
\compus. And on 28 December 1994, Unisys and \compus finally came to
an agreement: all companies writing software that creates or reads GIF
images will have to purchase a license from Unisys for using the LZW
algorithm. Note that this settlement only affected software developers using the
GIF format, and not people distributing GIF images.

This caused an uproar in the graphics developer community at the
time. Some of these upset developers formed a group that would develop
a new, \textit{free} graphics format that would serve as an improved
replacement to GIF. This new graphics format was PNG, which we shall
discuss in chapter \ref{cha:png}.

\subsection{Freedom}

But since 2006 all LZW related patents have expired. Software
developers are in other words finally free to use the LZW algorithm
just as they please, without having to request a license from Unisys
for doing so. And this also had the important consequence that the GIF
format was finally free from the shackles of Unisys.

\section{Format Version}

There are actually two version of the GIF format: version 87a,
\cite{gif87a}, and 89a, \cite{gif89a}. Version 89a is the newer of
these two versions and was released in 1989. GIF images that are of
version 87a don't support all of the features of version 89a and they
are nowadays very rare. And since version 89a is backwards compatible
with version 87a, we'll only be discussing version 89a in this
chapter.

\section{Building Blocks of the format}

Let us now go through the building blocks of the GIF format.

\subsection{Blocks}

The GIF format is organized into blocks. GIF blocks are very much like
TGA sections. The data that blocks consists of is specified in the two
kinds number of number types \textit{byte} and \textit{unsigned}. They
are defined like this:

\begin{description}
\item[byte] An 8-bit unsigned integer. Range: from 0 to $2^8 - 1 = 255$.
\item[unsigned] A 16-bit unsigned integer. Range: from 0 to $2^{16} -
  1 = 65535$.
\end{description}

Some blocks are optional, while others must be found in a valid GIF
file.

\subsection{Data Sub-blocks}
\label{sec:gif-data-sub-blocks}

Data Sub-blocks are used to store data that by definition is
sequential. An example of such data is the compressed color data,
which is just a long sequence codes that were outputted during the
compression of the image. Let's go through the parts of a single data
sub-block:

\subsubsection*{Block Size(Byte)}

At the beginning of every sub-block is its size. Since it is stored in
a byte, this has the consequence that a single sub-block has a maximum
size of $255$.

\subsubsection*{Block Data Values(Bytes)}

Following the block size is sequence of bytes. These bytes are the
actual data of the sub-block. The number of bytes in a single
sub-block is the value of the previous field.

The sub-blocks are read one by one until the block terminator found:

\subsubsection{Block Terminator}

If after reading a sub-block the next byte found is 0, that means
that you have found the empty sub-block. This sub-block is also
known as the block terminator. Should such a block be discovered, you
have reached the end of a sub-blocks sequence.

\subsubsection{An example}

So how would the string $ERICA$ be stored using data sub-blocks? We
first let the pair $(S,D)$ represent a sub-block, where $S$ is the
size of the block and $D$ is the data is block. The block terminator
is represented by the pair $(0,)$.

The string $ERICA$ can then be represented by the sequence of
sub-blocks $(5,ERICA)(0,)$. The block terminator must always terminate
a sequence of sub-blocks. But this is not the only way of representing
that string; $(3,ERI)(2,CA)(0,)$ is another perfectly legal way of
doing it. But the first sequence of obviously more space efficient,
since only $1 + 5 + 1 = 7$ bytes are required to store it, while the
former sequence requires $1 + 3 + 1 + 2 + 1 = 8$ bytes of storage.

\subsection{Packed Fields}

Another kind of data storage mechanism found in the GIF format are
packed fields. Packed fields simply means that data is stored in the
separate bits of a single byte. We'll be using our normal conventions
to denote the separate bits, so that in the number $0001\ 0011$ bits 0
to 1 has the value $3$ while bit $4$ has the value $1$.

\subsection{Extension Blocks}

A special kind of block is an extension block. To make these blocks
easier to identify, the extension blocks always begin with the fixed
value \hex{21}. This value is also known as the extension
introducer. Following the extension
introducer is the extension label, which is always stored in a
byte. This field identifies the kind of an extension.

After these two bytes you can find a sequence of sub-blocks containing
all of the data of the extension block. The data is stored like this
to make it easier to skip over the extension block, because the data
of some extension blocks is necessary to properly render the image.

\section{Header Blocks}

Now we will be describing all the possible kinds of blocks that can
occur in a GIF file. First of are the header blocks.

\subsection{Header(Required)}

This block will always be found first in a GIF file.

\subsubsection*{Signature(3 bytes)}

Identifies the file as a GIF-file. This field always has the value of
the ASCII string ``GIF''(non-NULL-terminated).

\subsubsection{Version(3 bytes)}

Gives the version of the GIF file. This field can only have two
possible values: 87a and 89a. Both these two values are stored as
ASCII strings.

\subsection{Logical Screen Descriptor(Required)}

Following the header block is always the logical screen descriptor
block.

\subsubsection{Logical Screen Width(Unsigned)}
\subsubsection{Logical Screen Height(Unsigned)}

These give the size of area on the screen where the image will be
rendered. So these fields are basically the measurements of the
image. However, do note that the GIF format allows for several images
to be stored in a GIF file. This makes the GIF format capable of
animation. These images can have measurements that are smaller than
but not greater than the logical screen measurements.

\subsubsection{Packed Fields(byte)}

This packed field contains data about the global color table of the
file. This field will always be found here, even if there is no global
color table in the file to be found.

\paragraph{Bit 7 --  Global Color Table Flag}

This flag indicates whether there is a global color table in the
image.

\paragraph{Bits 4-6 -- Color resolution}

This field has a very misleading name. You may think this field is
simply used to indicate the color depth of the image, but no, this
field indicates the number of bits in the \textit{original image} per
color channel, minus 1.

The GIF format only supports paletted color, and doesn't offer support
for RGB triplets stored straight in the color data. It only permits
for a palette of maximum length $256$, where every color has color
depth of $24$ bits. The GIF format can in other words only a represent
a very small subset of colors.

But since this field gives no rendering information about the image,
this field is pretty much useless and you can safely ignore it.

\paragraph{Bit 3 -- Sort Flag}

If this flag is set to true, the colors in the global color table are
sorted in order of decreasing importance. This means that the most
frequently used colors in the image are sorted first in the color
table. To cite the GIF specification \cite{gif89a}:

\begin{quote}
  This assists a decoder, with fewer available colors, in choosing
  the best subset of colors; the decoder may use an initial segment
  of the table to render the graphic.
\end{quote}

So this field may come in use when a GIF image is to rendered in an
environment with a very limited selection of colors, like old
monitors.  But since the monitors of today support a very large subset
of colors, so you can for the most part safely ignore this field.

\paragraph{Bits 0-2 -- Color Table Size}

This field is used to calculate the size of the global color table.
Let $n$ signify the value of this field, then the \textit{real} size
of the global color table is given by

\begin{equation}
  \label{eq:calc-global-color-table-size}
  \text{Real Color Table Size} = 2^{n + 1}.
\end{equation}

\subsubsection{Background Color Index(Byte)}

This field's value is the index of the background color of the
image. Parts of an image that are not covered by an image at all are
rendered in this color. This is made possible, because the GIF format
supports arbitrary position of images in a GIF image and it also
supports a fully transparent color.

\subsubsection{Pixel Aspect Ratio(Byte)}

We already discussed this value in chapter \ref{cha:tga}. To be more
specific, we discussed it in section \ref{sec:tga-extension-area}.

\section{Color Tables}

\subsection{Global Color Table(Optional)}

After the logical screen descriptor comes the global color
table. However, if the Global Color Table flag is set to
\textbf{false} the global color table will not occur at all within
the image!

The global color table is, just as in any other image format, a long
array of colors. Every color is given 24 bits of storage and every
color channel color is assigned an 8-bit number. The number of colors
in the color table is calculated according to equation \ref{eq:calc-global-color-table-size}.

\subsection{Local Color Table(Optional)}

If there is a not a global color table in the GIF image, a local color
table is instead used. The local color table can be found right before
the image data. This block is laid out and structured just like the
global color table block. Its size is however given by a field in a
block we will discus soon.

\section{Preimage Data Blocks}

The preimage data blocks always occur before the color data and help
the decoder in loading the color data. They also describe how the
color data should be rendered.

\subsection{Image Descriptor(Required)}

Before the image data there will always be an Image Descriptor. It
contains the information you need to know to properly render and
process the image data.

\subsubsection{Image Separator(Byte)}

This field identifies the block as an image descriptor and it always
has the value \hex{2C}.

\subsubsection{Image Left Position(Unsigned)}
\subsubsection{Image Top Position(Unsigned)}

These fields give the position of the image on the screen. If these
two fields both have the value zero, the image is rendered in the
top-left corner of the logical screen. If the values are, for
instance, $4$ and $2$, the image is shifted 4 pixels to the right and 2
pixels down before being rendered.

\subsubsection{Image Width(Unsigned)}
\subsubsection{Image Height(Unsigned)}

Specifies the size of the image.

\subsubsection{Packed Fields(Byte)}

\paragraph{Bit 7 -- Local Color Table Flag}

This flag indicates whether a local color table is found after this
block.

A separate image in a GIF file can have a local color table, specific
to only itself. If no global table can be found in the file, every
image in the GIF file must have a local color table.

However, if an image do have a global color table, but the existence
of a local color table is indicated by this field, that means that the
local color table will be used instead of the global color table for
this specific image.

\paragraph{Bit 6 -- Interlace Flag}

The row numbers we are using in this explanation will be zero
based. So row number $1$ is written as row number $0$ instead.

This flag indicates whether the image is interlaced. If an image is
interlaced, that means the order of the image data is not from the top
left corner to the bottom right corner. Rather, the rows of the image
data is rearranged into four different passes. The first $n_1$ row
constitutes of pass $1$. These rows are not the rows
$0,1,\dots,n_1-1$, but instead are the rows $8 \cdot 0, 8 \cdot 1,
\dots, 8(n_1-1)$. So pass 1 is every 8:th, starting from row $0$. The
rest of the passes are, if we let $n_x$ represent the number is rows
in pass $x$:

\newcommand{\passrows}[3]{$#1 \cdot 0 + #2, #1 \cdot 1 + #2, \dots,
  #1(n_{#3}-1) + #2$}

\begin{description}
\item[Pass 1] Every 8:th row, starting with row 0: \passrows{8}{0}{1}
\item[Pass 2] Every 8:th row, starting with row 4: \passrows{8}{4}{2}
\item[Pass 3] Every 4:th row, starting with row 2: \passrows{4}{2}{3}
\item[Pass 4] Every 2:th row, starting with row 1: \passrows{2}{1}{4}
\end{description}

The rows of pass $1$ will come first in the image data, then the rows
of pass $2$, then pass $3$, and finally the rows of pass $4$ always
comes last.

For an image of height $20$ rows, the rows would assigned to the
passes shown in table \ref{tab:gif-interlacing}. Here $n_1 =
3$, so the rows of pass $1$ are $0$,$8$ and $16$. $n_2 = 2$, so the
rows of pass $2$ are $4$ and $12$. $n_3 = 5$, so the rows of pass $3$
are $2$, $6$, $10$, $14$ and $18$. $n_4 = 10$, so the rows of the
final pass $4$ are $1$, $3$, $5$, $7$, $9$, $11$, $13$, $15$, $17$,
$19$.

But is it guaranteed that this interlacing method will not miss a single
row? Yes it is; this follows from the fact that

\begin{equation*}
  \frac{1}{8} + \frac{1}{8} + \frac{1}{4} + \frac{1}{2} = \frac{4}{4}
  = 1
\end{equation*}

In algorithm \ref{alg:gif-decompression} it is shown how to
uninterlace the interlaced decompressed image data. Since this
algorithm is pretty much self-explanatory, I will not include an in
depth discussion of it.

\begin{algorithm}[H]
  \caption{Undoing the interlacing of the uncompressed GIF color data.}
  \label{alg:gif-interlace}
  \begin{algorithmic}[1]
    \linecomment{Set the array to the sequence of number $0,4,2,1$}
    \Let{$startingRow$}{$\{0,4,2,1\}$}
    \Let{$rowIncrement$}{$\{8,8,4,2\}$}

    \Let{$i$}{$0$}
    \Let{$row$}{$0$}

    \linecomment{In this algorithm, the pass numbers are zero based}
    \ForTo{$pass$}{$0$}{$4$}
      \Let{$row$}{$startingRow[pass]$}

      \While{$row < imageHeight$}

        \ForTo{$column$}{$0$}{$imageWidth$}

          \Let{$j$}{$row * width + column$}
          \Let{$uninterlacedColorData[j]$}{$uncompressedColorData[i]$}
          \Let{$i$}{$i + 1$}

        \EndForTo

        \Let{$row$}{$row + rowIncrement[pass]$}

      \EndWhile

    \EndForTo

  \end{algorithmic}
\end{algorithm}

% But why is interlacing even necessary? Why can't you just store the
% pixels in order, from the bottom left corner of the image to the
% bottom right corner?

\todo{explain why interlacing is necessary.}

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    Row Number & Interlace Pass \\
    \midrule
    0 & 1 \\
    1 & 4 \\
    2 & 3 \\
    3 & 4 \\
    4 & 2 \\
    5 & 4 \\
    6 & 3 \\
    7 & 4 \\
    8 & 1 \\
    9 & 4 \\
    10 & 3 \\
    11 & 4 \\
    12 & 2 \\
    13 & 4 \\
    14 & 3 \\
    15 & 4 \\
    16 & 1 \\
    17 & 4 \\
    18 & 3 \\
    19 & 4 \\
    \bottomrule
  \end{tabular}
  \caption{}
  \label{tab:gif-interlacing}
\end{table}

\paragraph{Bit 5 -- Sort Flag}

This indicates whether the color data in the local color table is
sorted. This works in the exact same as it does in global color
table.

\paragraph{Bit 3-4 -- Reserved}

These bits are reserved, meaning that their both values are always set
to $0$. You should simply ignore these bits.

\paragraph{Bit 0-2 -- Size of Local Color Table}

Helps calculate the size of the local color table. If this value is
$n$, then the actual size is $2^{n + 1}$.

\subsection{Graphic Control Extension(Optional)}

The Graphic Control block is an extension block that mostly controls
how the animation is done in an animated GIF image.

\subsubsection{Extension Introducer(Byte)}

This field identifies the block as an extension block and it always
contains the value \hex{21}.

\subsubsection{Graphic Control Label(Byte)}

Identifies the extension block as a graphic control extension
block. Contains the fixed value \hex{F9}.

\subsubsection{Block Size(Byte)}

The data in the graphic control extension block is contained in one
single sub-block. This is the size of that single sub-block, which is
always $4$.

\subsubsection{Bits 5-7 -- Reserved}

Unused.

\subsubsection{Bits 2-4 -- Disposal Method}

When a GIF image is animated, the file essentially contains a sequence
of images. When viewing the GIF file, these images are displayed one
after one to form an animation. After each image has been displayed,
you can do different things to dispose of the previous image when
current image is to be displayed. The action that will be performed in
order to dispose of the former image is specified by this field. The
different possible actions are:

\begin{description}

\item[0] No disposal is specified. This basically means that the
  decoder doesn't need to, nor is required to, do anything at all.

\item[1] Do not dispose the previous image. The current image is
  rendered over the previous one. Visible parts of the current image
  will then cover parts of the previous image. The parts of the
  previous image that are not covered will still be visible. Remember
  that the GIF format allows for positioning of images. This is done
  by the Image Position values in the Image Descriptor block.

  This is very useful for when you in an animation only want change
  small parts of an image.

\item[2] After the former image has been displayed, the area used by
  it must be restored to the background color before the next image is
  to be rendered. The background color was specified by the Background
  Color Index field of the Logical Screen Descriptor block.

\item[3] Restore to previous. Meaning that the decoder must restore
  the area taken up by the former image and replace it with what was
  rendered there before the former image was rendered over it. On
  these areas, the image that came before the former image will be
  rendered.


\end{description}

\subsubsection{Bit 1  -- User Input Flag}

If this flag is true, the loading of the next block will continue only
after user has entered some input determined by the application
loading the image. One example of such an input is simply the user
pressing the Enter key.

But in practice, this field is never used and practically no modern
applications in existence support it.

\subsubsection{Bit 0 -- Transparency Flag }

This flag indicates whether the Transparency Index field should be
used.

\subsubsection{Delay Time(Unsigned)}

This specifies the number of centiseconds the decoder should wait
after having rendered the image following this block. This is very
useful for when making animated GIFs and you want to create a time
delay between the frames. A centisecond is a hundredth of a second:

\begin{equation*}
  \SI{1}{\centi\second} = \frac{1}{100}\si{\second}
\end{equation*}

\subsubsection{Transparency Index(Byte)}

If this field is to be used(as is specified by the Transparency
Flag.), it contains the color index that should not be rendered at all
when encountered. This color can be seen as the transparent color in
the color palette

So as you can see from this field, the GIF format supports a very
simple form of transparency. But it doesn't support any form of the
alpha color channel. Either a pixel is colored or it is not, there is
no state in between.

\subsubsection{Block Terminator(Byte)}

This field terminates the sub-block that this extension block
consists of and always has the value $0$.

\section{Graphic-Rendering blocks}

For storing the data to be rendered from a GIF image these blocks
are used.

\subsection{Table Based Image Data}

Now we have finally reached the most important kind of block that you
can find in a GIF file: the table based image data block. Since this
block is rather complex, we'll explain it in two steps: first we'll
explain the fields of this block, and then we'll explain how to
extract the image data from the data given in the fields of this
block.

\subsubsection{LZW Minimum Code Size(Byte)}

The GIF format uses a variation of the LZW compression algorithm
for storing it's color data. The huge difference between the
original LZW algorithm and the version used in GIF is that the
code sizes of the individual codes increase as bigger codes are
needed in the image data.  Let the value of this field be $n$, then
the starting code size is $n + 1$.

\subsubsection{Compressed Image Data(Sub-blocks)}

The compressed image data is stored in this sequence of sub-blocks.

\subsubsection{The Compression Algorithm}

Now we are to discuss how to decompress the color data using the
information given in the two previous fields. The full decompression
algorithm is given in algorithm \ref{alg:gif-decompression}. As you
can see, it is very similar to the original LZW algorithm. Let us
now go through the most important differences.

At the beginning the algorithm all the indexes of the palette are
assigned codes in a compression table. The values of these codes are
the values of the indexes. Two additional codes are also added to the
color table: the clear and the end codes. Let the size of the color
palette be $n$, then the clear code has the code value $n$(the highest
index in the palette has the code value $n-1$), and the end code has
the value $n+1$. If the Clear Code is found, the compression table is
reset and restored to it's initial state. This means that the codes
added to the table during the compression are thrown away and that the
code size is reset. If the End Code is found, that means that the end
of the compressed data has been reached, and that the decompression is
done.

If, for example, of our color table simply consisted of the colors
black and white, the initial table that would be used in the beginning
of then decompression algorithm is then given in table
\ref{tab:example-gif-color-table}.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    Meaning & Code \\
    \midrule
    Black & 0 \\
    White & 1 \\
    Clear Code & 2 \\
    End Code & 3 \\
    \bottomrule
  \end{tabular}
  \caption{Example of an initial GIF compression table.}
  \label{tab:example-gif-color-table}
\end{table}

And the second huge difference in the GIF version of the LZW
algorithm, is that the code size increases. Remember, the initial code
size minus $1$ was given in a field of this block. Every time a new
code is added to the table, we check if the size of the current code
is also equal to the max value of the current code size. If so, and
the code size is not equal to it's maximum allowable value in the GIF
format, $12$, then the value of the code size is increased by one.

\begin{algorithm}[H]
  \caption{GIF Decompression algorithm}
  \label{alg:gif-decompression}

  \newcommand{\InputCodeSize}{\Call{inputCode}{$codeSize$}}

  \begin{algorithmic}[1]

    \Let{$ClearCode$}{$colorTableSize$}
    \Let{$EndCode$}{$colorTableSize + 1$}

    \Let{$IntitalCodeSize$}{\VoidCall{ReadByte} $+ 1$} \Comment{
      Read the initial code size}
    \Let{$codeSize$}{$IntitalCodeSize$}

    \linecomment{In the beginning of the compressed data a clear code
      is always found. By doing this, we skip the clear code.}
    \State \InputCodeSize

    \linecomment{Fill the table with the color palette and the two
      extra codes}
    \State \VoidCall{resetCompressionTable}
    \Let{$nextCode$}{$colorTableSize + 2$}

    \Let{$oldCode$}{\InputCodeSize}
    \State \Call{outputCode}{oldCode}

    \Let{$character$}{$oldCode$}
    \Let{$newCode$}{\InputCodeSize}

    \While{$newCode != EndCode$}

    \If{$newCode = ClearCode$}

    \linecomment{Reset the compression table if a clear code is
      found}

    \State \VoidCall{resetCompressionTable}
    \Let{$nextCode$}{$colorTableSize + 2$}
    \Let{$codeSize$}{$IntitalCodeSize$}

    \Let{$oldCode$}{\InputCodeSize}
    \State \Call{outputCode}{oldCode}

    \Let{$newCode$}{\InputCodeSize}

    \EndIf

    \If{$\NOT$ \Call{IsInTable}{$newCode$}}
    \Let{$string$}{\Call{translate}{oldCode}}
    \Let{$string$}{$string + character$}
    \Else
    \Let{$string$}{\Call{translate}{$newCode$}}
    \EndIf

    \State \Call{outputString}{$string$}

    \Let{$character$}{$string[0]$}

    \If{$nextCode \leq (2^{12} - 1)$}

    \State \Call{$AddToStringTable$}{$nextCode, oldCode, character$}

    \If{$nextCode == 2^{codeSize} - 1 \AND codeSize \neq 12$}
    \Inc{codeSize}{1}
    \EndIf
    \Inc{nextCode}{1}
    \EndIf

    \Let{$oldCode$}{$newCode$}

    \Let{$newCode$}{\VoidCall{$ReadByte$}}

    \EndWhile

  \end{algorithmic}
\end{algorithm}

\subsection{Plain Text Extension}

The second way of storing rendering data in a GIF file is through the
plain text extension. This extension basically allows you to render
text as graphic. While this might have been seen as a good idea at the
time it was thought up, nowadays practically no programs implement
support for this block. We will for that reason not discuss this
block at all.

\section{Miscellaneous Blocks}

\subsection{Trailer(Required)}

Once we have reached the trailer we have also reached to the end of
the GIF file. Once the trailer block has been reached, the decoder's
job is done. It is a single field block containing only one value:

\subsubsection{GIF trailer(Byte)}

Identifies the block as the trailer block. Always has the value
\hex{3B}.

\subsection{Comment Extension(Optional)}

The comment extension block allows you to embed a textual comment into
a GIF file. So it could be used to store simple metadata in a GIF file.

\subsubsection{Extension Introducer(Byte)}

Identifies the block as an extension block. Always contains the
value \hex{21}.

\subsubsection{Comment Label(Byte)}

This label identifies this extension block as a comment extension
block. Contains the constant value \hex{FE}.

\subsubsection{Comment Data(Data Sub-block)}

Containing the comment data is just a sequence of data sub-blocks. The
comment data stored using ASCII encoding.

\subsubsection{Block Terminator(Byte)}

This zero-length data block terminates the data sub-blocks and hence
the comment data. Has the fixed value $0$.

\subsection{Application Extension}

The application extension block allows you to give information to a
specific application about a GIF file. Because this block is
entirely application specific, it may seem pointless to give a
thourough disscussion of this block. But since it is this block that
allows an animated GIF image to be infinitely looped, I will give this
block a thorough discussion.

\subsubsection{Extension Introducer(Byte)}

Identifies the block as an extension block. Always has the value
\hex{21}.

\subsubsection{Extension Label(Byte)}

Identifier the extension block as an application extension
block. Always has the value \hex{FF}.

\subsubsection{Block Size}

The block size of the application extension block. Has the constant
value $11$.

\subsubsection{Application Identifier(8 Bytes)}

This identifies the application that this block is supposed to
affect.

\subsubsection{Application Authentication Code(3 Bytes)}

These values are used to show the that Application Identifier is
authenticated to the application given in the application
identifier.

\subsubsection{Application Data(Sub-blocks)}

This sequence of data sub-blocks contains the actual data passed to
the application. Different data given in this sequence of data
sub-blocks often results in the application reacting differently to
this block.

\subsection{Infinite GIFs}

Using the application extension we can make an animated GIF repeat
it's animation infinitely long. Otherwise, the animation would just
repeat one time and then stop.

This is done using the Netscape Application Extension. Here the
Application Identifier is assigned the string ``Netscape'' and the
Application Authentication Code is given the string ``2.0''. The
application data of this extension always consists of a single
sub-block of length 3. Let us go through the values of this single
sub-block: \cite{frazier97:_all_about_gif89}

\subsubsection{Constant(Byte)}

This is field doesn't really have a formal name so I named it
constant, because it always has the constant value $1$.

\subsubsection{Iterations(Unsigned)}

This number indicates the number of times the animation should be
repeated. If this value is $0$ the animation will loop infinitely.

The Netscape application extension block was first used by the web
browser Netscape. Other software developers then saw that the block
was a good idea and started implementing support for the block in
their applications, and that is how the use of this block spread. The
name Netscape Application Extension has stuck ever since, because you
didn't want to break old GIFs just because you wanted to make a silly
name change \cite{walte96:_web_scrip_secret_weapon}.

\section{GIF syntax}
\label{sec:gif-syntax}
So there are quite a few kinds of block in the GIF format. But in what
order must they come for a GIF file to be considered syntactically
valid, by the sytnax of GIF files? The syntax of valid GIF files, as
given in \cite{gif89a}, is illustrated by figure
\ref{fig:gif-grammar}.

\begin{figure}
  \centering

  \inputtikz{gif_grammar}

  \caption{The grammar of a valid GIF-file.}
  \label{fig:gif-grammar}
\end{figure}

