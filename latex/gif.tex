\begin{comment}
  \bibliography{project.bib}
\end{comment}

\chapter{\gif -- Graphics Interchange Format}
\label{cha:gif}

\begin{refsection}

  \section{History}

  % http://netghost.narod.ru/gff/graphics/book.htm

  \subsection{Troublesome Patents}

  AS you may rememerber from the last chapter, the \lzw was
  inventented by Terry Welch. However, he also filed a software patent
  for the algorithm. This patent was U.S. Patent 4,558,302
  \cite{welch85:_u,roelofs09:_histor_portab_networ_graph_png_format}.

  \newcommand{\compus}{CompuServe\xspace}

  And in 1987, \compus started designing a new \textit{portable and
    compressed} image format called \textit{Graphics Interchange
    Format}, abbreviated \gif. To perform the compression in this new
  format, \compus chose a small variation of the compression algorithm
  \lzw. The next thing that \compus did, was that they released this fresh
  image format to the general public.

  But when they released it, they and the rest of the world had no idea
  that Unisys where pursuing a patent for the \lzw compression
  algorithm. And once Unisys had gained the patent and informed the rest
  of the world of this, the GIF format had already been released!

  But it wasn't until 1993 that Unisys actually started pursuing
  companies that were selling software using the \lzw algorithm. And one
  of those companies that Unisys started attacking because of this was
  of course \compus. And at christmas day 1994 Unisys and \compus
  finally came to an agreement: all programmers writing software that
  creates or reads images will have to have a license from Unisys.

  This of course causes an uproar in the graphics developer community
  at the time. Some of these developers formed that would develop a new
  \textit{free} graphics format that would replace \gif, because
  \gif was very popular at the time
  . This
  new graphisc format was \png, which we will discuss in chapter
  \ref{cha:png} \cite{roelofs09:_histor_portab_networ_graph_png_format,caie:_sad}.

  \subsection{Freedom at last}

  But since 2006 all \lzw related patents have expired. Software
  developers are in other words finally free to use the \lzw algorithm
  just as they please. And this also means that the \gif format is
  finally free from the shackles of Unisys. So programmers are free to
  write and develop software that deals with \gif images \cite{caie:_sad}.

  \section{Introduction to the \gif format}

  So, in this chapter we'll be discussing the inner workings of \gif
  images. Because the \gif format also supports animation, it is
  slightly more advanced than the \tga format we discussed in chapter
  \ref{cha:tga}. Understanding the general structure of the image
  format is actually the easiest part, the hardest part of the format
  is the compression algorithm that it uses, which is a small
  variation of the \lzw algorithm. But since we have already discussed the \lzw
  algorithm in chapter \ref{cha:lzw}, this will only be marginally
  difficult.

  There are actually two version of the \gif format: version 87a and
  89a. Version 89a is obviously the newer of these two versions and
  was released in 1989. \gif images that are of version 87a don't
  support all of the features of version 89a and they are nowadays
  very rare. And since 89a is backwards compatible with 87a, we'll
  only be focusing on version 89a \cite{gif89a,gif87a}.

  The entire version 89a of the \gif format is specified in this
  document: \cite{gif89a}.

  \section{The building blocks of the \gif format}

  \subsection{Blocks}

  The \gif format is organized into blocks. There are three kinds of
  blocks:

  \begin{enumerate}
  \item  control blocks
  \item graphic-rendering blocks
  \item special purpose blocks
  \end{enumerate}

  Controls blocks are used to specify how an image should be
  displayed to and how to image data should be read.

  Graphic rendering blocks are used to actually render, display, an
  image on the screen. They tend to contain the color data of the
  image. Controls blocks affect how graphics rendering blocks are to
  be displayed. Control blocks always occur before graphics rendering
  blocks and they often have a limited \textit{scope}, meaning that
  they almost always only affect the graphics rendering block that
  follow them. You'll understand better what this means later.

  And miscellaneous things that aren't handled by the two former
  block types are done by the special purpose blocks.

  The data that blocks consists of is specified in two kinds number of
  types called \textit{byte} and \textit{unsigned} respectively. They
  are defined like this:

  \begin{description}
  \item[byte] An 8-bit unsigned integer.
  \item[unsigned] A 16-bit unsigned integer.
  \end{description}

  \subsection{Data Sub-blocks}

  Sub-blocks are used to store data in \gif images that definition is
  sequential. Example of such data is the color data. They are really
  just a long sequence of bytes. Let's go through the parts of a sub-block one after one:

  \subsubsection*{Block Size(Byte)}

  At the beginning of every sub-block is its size. This value is fit
  into a byte, meaning that the maximum size of sub-block is only
  255.

  \subsubsection*{Block Data Values(Bytes)}

  Following the block size is sequence of bytes. These bytes are the
  value of the sub-block. The number of bytes in the sub-block is of
  course the block size that was specified by the block size.

  So the maximum size of sub-block is only $255$ bytes. And data
  sub-blocks is just sequence of sub-blocks such as this. A sub-block
  is read one by one in such a sequence until the block terminator is found:

  \subsubsection*{Block Terminator}

  If after reading a sub-block the next byte is 0, that means that you
  have found the emmpty sub-block. This sub-block is also known as the
  block-terminator. Should such a block be discovered you have reached
  the end of the sequence.

  Figure \ref{fig:gif-data-sub-blocks} demonstrates how the string
  ``ERICA'' would be stored using data sub-blocks. As can be seen, it
  is perfectly acceptable that the data is split over several
  sub-blocks. But this example may seem a bit silly, because the
  string ``ERICA'' easily be fit into a single block instead o
  splitting it into. But this was only done for demonstrative purposes
  and more efficent way of storing the string would be putting it all
  into one block of length $5$.

  Because the data is split up over several sub-blocks, reading it may
  be a bit tricky. Algorithm \ref{alg:gif-sub-blocks} demonstrates one way of reading all the
  data of a sequence of sub-blocks into one array.

  \begin{figure}
    \centering
    \inputtikz{gif_subblocks}
    \caption{\gif Data Sub-Blocks}
    \label{fig:gif-data-sub-blocks}
  \end{figure}


  \begin{algorithm}[H]
    \caption{Reading all the data of sequence of sub-blocks into one array.}
    \label{alg:gif-sub-blocks}
    \begin{algorithmic}[1]
      \Let{$blockSize$}{\VoidCall{ReadByte}}
      \Let{$i$}{$0$}
      \Repeat
      \Repeatn{$blockSize$}
      \Let{$data[i]$}{\VoidCall{ReadByte}}
      \Inc{$i$}{$1$}
      \EndRepeatn

      \Let{$blockSize$}{\VoidCall{ReadByte}}

      \Until{$blockSize == 0$}
    \end{algorithmic}
  \end{algorithm}


  \subsection{Packet Fields}

  Another kind of data storage mechanism are packed fields. In packed
  fields the fields values are stored bits in a byte. To make things
  easier we'll be calling the top bit, the one usually called bit 7 or
  8, bit 1, and we'll call the lowest bit, that is usually called bit
  1 or 0, bit 8. See also figure \ref{fig:gif-packed-fields} for a
  more detailed byte bit-layout.

  \begin{figure}
    \centering
    \inputtikz{gif_packed_fields}
    \caption{The order of the bits we'll be describing in packed fields.}
    \label{fig:gif-packed-fields}
  \end{figure}

  \subsection{Notation}

  Now we will be describing all the possible kinds of sub-blocks that
  can occur in a GIF file. We'll be describing them in the order they
  usually appear. I will also be telling which blocks are required and
  which blocks are optional.

  \section{Header Blocks}

  Coming first in the GIF file format are the header blocks.

  \subsection{Header(Required)}

  The header contains the mag numbers of the GIF format and is always
  first in a proper \gif.

  \subsubsection*{Signature(3 bytes)}

  Identifies the file as \gif-file. It always contains the
  value ``GIF''.

  \subsubsection{Version(3 bytes)}

  Contains the value of the version of the \gif-file. Remember, there
  are two version of the \gif format: ``87a'' and ``89a'', and these
  two are the two only possible values of this field.

  \subsection{Logical Screen Descriptor(Required)}

  Following the header block is always the logical screen descriptor
  block. This block contains information about the global color
  table(we'll discuss this block very soon) and about the image
  measurements.

  \subsubsection{Logical Screen Width(Unsigned)}

  Width of the logical screen where the image will be rendered. So
  this fields is basically the image width. However, do note that the
  \gif format allows several images to be stored in a \gif-file to
  allow for such things as animation. These images can measurements
  that are smaller than, but not greater than the logical screen
  measurements.

  \subsubsection{Logical Screen Height(Unsigned)}

  Gives the height of the logical where the image will be rendered.

  \subsubsection{Packed Fields}

  This packed field contains data about the global color table. Even
  if there's not a global color table it will still occur in the
  logical screen descriptor.

  \paragraph{Bit 1 --  Global Color Table Flag}

  This flag indicates whether there is a global color table in the
  image. The global color table always comes after the logical screen
  descriptor, so we'll be describing that field pretty soon. This
  field works like many other flags like a simple boolean value; if it
  is \textbf{1} it is \textbf{true}, otherwise it must be zero and is
  therefore \textbf{false}.

  \paragraph{Bit 2-4 -- Color resolution}

  Now, this field has a very misleading name. You may think this field
  is simply used to indicate the color depth of the image, but it is
  not. This field indicates the color resolution of the
  \textit{original image}! You see, the \gif has a very limited range
  of colors. It only permits for a palette of maximum length 256,
  where every color has color depth of 24 bits. You can however also
  vary the size of this palette, making the resulting image smaller,
  but also resulting in a image of lower quality.

  Let's we have an image some other forein format and we wan't to
  convert it to a \gif. We first note that the color depth of this
  example is 24. This means that the number of bits reserved to each
  primary color is 8. So, when converting this image to a \gif the
  value of this field will 7, which is $8-1$, because remember; the
  maximum value of a 3-bit number is $2^3 - 1 = 7$.

  In other words: the value of this field is number of bits er primary
  in the original image minus.

  But isn't this field really useful to reading the color data? Why
  yes, you are right. The only real usage I can see to this, is to how
  much image quality this image has compared to the original image,
  but it is very rarely you would want to do that, and you tend to get
  much better result by comparing the converted \gif image with the
  original image.

  \paragraph{Bit 5 -- Sort Flag}

  If this flag is true, the colors in the global color table are
  sorted in the order decreading importance. This typically means that
  the most frequently used colors are sorted first. According to
  \cite{gif89a} this is to, and I quote:

  \begin{quote}
    This assists a decoder, with fewer available colors, in choosing
    the best subset of colors; the decoder may use an initial segment
    of the table to render the graphic.
  \end{quote}

  What this basically means, is that the decoder can get a away with
  only loading the first few colors of the color table and still get a
  decently we'll rendered image with some few rarely used color not
  rendered. This is done to make the loading and rendering process
  quicker, I suspect.

  But this fields is as good never used nowadays. You can perfectly
  safely ignore of it without harming the loading process.

  \paragraph{Bit 6-8 -- Color Table Size}

  This field is used to calculate the size of the global color
  table. If we let the variable $n$ signify the value of this field,
  then the \textit{real} size of the global color table can be
  calculated by the formula:

  \begin{equation}
    \label{eq:calc-global-color-table-size}
    \textrm{Global Color Table Size} = 2^{n + 1}
  \end{equation}

  \subsubsection{Background Color Index(Byte)}

  This field's value is the index if the color table that should be
  considered fully transparent. That is: this field gives the value of
  the color table index that transparent.

  So as you can see from this field, the \gif format supports a very
  simple form of transparency. But it doesn't support any form of the
  alpha color channel. Either a pixel is color or it is not, there is
  no state in between.

  \subsubsection{Pixel Aspect Ratio(Byte)}

  The pixel aspect is ratio is defined as

  \begin{equation*}
    \textrm{Pixel Aspect Ratio} = \frac{\text{Pixel Width}}{\text{Pixel Height}}.
  \end{equation*}

  todo: fix

  \section{Color Tables}

  \subsection{Global Color Table(Optional)}

  After the logical screen descriptor comes the global color
  table. However, if the Global Color Table flag is set to
  \textbf{false}, the global color table will not occur at all within
  the image!

  The global color table is just as in any other format a just long
  array of color. Every color is given 24 bits and every primary color
  is given 8-bits. So the length of this field is $3 \cdot
  \textrm{Global Color Table Size}$. In which $\textrm{Global Color
    Table Size}$ is calculated in equation
  (\ref{eq:calc-global-color-table-size}). Figure
  \ref{fig:gif-color-table} shows an example of a global color table
  in your typical \gif image. The size of the global table size given
  in the packed field of the logical screen descriptor will in the
  case of this color table have the value $0$. The number of bytes in
  this color table can then be calculated like so:

  \begin{figure}
    \centering
    \inputtikz{gif_color_table}
    \caption{Example of \gif color table }
    \label{fig:gif-color-table}
  \end{figure}

  \begin{equation*}
    3 \cdot 2^{0 +1} = 3 \cdot 2^1 = 3 \cdot 2 = 6
  \end{equation*}

  \subsection{Local Color Tables(Optional)}

  If there is a not a global color table in the \gif image, a local
  color table is instead used. the local color table is always right
  before the image data, or the table based image data as we also
  refer to it. This laid out just like the global color table. It's
  size is however given by a block we will discuses later.

  \section{Preimage data blocks}

  The preimage data blocks always occur before the color data and help
  the decoder in loading data and tells how the image is to be
  rendered.

  \subsection{Image Descriptor(Required)}

  Before the image there will \textit{always} be a Image
  Descriptor. It contains the data you need to know to properly render
  and process the image data.

  \subsubsection{Image Separator(Byte)}

  This identifies the field as an image descriptor. It always has the
  value \hex{2C}. As you will soon see, this field is very useful for
  when loading a \gif image.

  \subsubsection{Image Left Position(Unsigned)}
  \subsubsection{Image Top Position(Unsigned)}

  The position of the image on the screen in respect to the logical
  screen descriptor specified in the logical screen descriptor.

  \subsubsection{Image Width(Unsigned)}
  \subsubsection{Image Height(Unsigned)}

  These fields allows you to specify the size of the image.

  Do note that these 4 fields allow you to move around the image on
  the logical screen pretty much freely. This turns out the be very
  useful when making animated images. More on this later \dots

  \subsubsection{Packed Fields(Byte)}

  \paragraph{Bit 1 -- Local Color Table Flag}

  This flag tells whether a local color table is found after this
  block. 

  An image in a \gif image can have a specific color table, local to
  only itself. An image \textit{needs} to have a local color table if
  no global color table is in the image. If no global table is in the
  image \textit{every} image in the \gif must have a local color
  table.

  However, if an image do have a global color table, but the existence
  of a global color table is indicated by this, that means that the
  local color table will be used instead of the global color table.

  \paragraph{Bit 2 -- Interlace Flag}

  This flag indicates whether the image is interlaced.

  \paragraph{Bit 3 -- Sort Flag}

  This indicates whether the color data in the local color table is
  sorted. This works in the exactly same as it does in global color
  table.

  \paragraph{Bit 4-5 -- Reserved}

  These bits are reserved, meaning that their both values are set to
  $1$ and that they are \textit{unused}.

  \paragraph{Bit 5-8 -- Size of Local Color Table}

  The size of the local color table. The actual size of the local
  color table is calculated in the same way it is in the global color
  table:

  \begin{equation*}
    \textrm{Local Color Table Size} = 2^{n + 1}
  \end{equation*}

  \subsection{Graphic Control Extension}

  

  \section{Rendering blocks}

  \subsection{Table Based Image Data}

  \subsection{Plain Text Extension}

  \section{Ending}

  \subsection{Trailer}

  \section{Miscellaneous Blocks}

  \subsection{Comment Extension}

  \subsection{Application Extension}

  \section{Wrapping it up}

  % netscape application extension
  % http://www.etsimo.uniovi.es/gifanim/gifabout.htm#net-extension

  % more gif
  % http://netghost.narod.ru/gff/graphics/summary/gif.htm#GIF-DMYID.1

  % file:///C:/Users/Eric/Downloads/WEBSSW/CH7.HTM#AnimatedGIFs

  % show syntax of gif file.

  \printbibliography[heading=subbibliography]

\end{refsection}
