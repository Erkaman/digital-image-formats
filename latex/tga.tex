\begin{comment}
  \bibliography{project.bib}
\end{comment}

% TODO: describe the seek Seek functions and it's options carefully.
\chapter{TGA -- Truevision Graphics Adapter}
\label{cha:tga}

\begin{refsection}

  \section{Introduction}
  \label{sec:tga-introduction}

  The whole purpose of this book was to give a good understanding of
  how image formats really work under the hood. But we couldn't just
  have jumped right in, we required knowledge of how color is stored
  digitally and how compression algorithms work. Now it's time to put
  that knowledge to good use. \textit{All} the compression algorithms
  we have just covered are used in the image formats we are going to
  explore. And of course, knowledge how color is stored digitally is
  going to be purely essential to go on.

  Now it's time to explore our real first image format:
  TGA\index{TGA}. But why TGA of all image formats? Because the format
  is an extremely simple one at that, yet it is actually widely used
  in certain areas, like games and video processing. And it has all
  the parts common to all image formats and it even features a very
  simple compression algorithm: PackBits RLE, which was one of the
  algorithms we covered in chapter \ref{cha:compress-techn}.

  But the TGA format is also has its share of complexity. To make the
  format more extensible for programmers such as us, several features
  were added in the second version of the format. But we will only
  mention but not explain these features as they are not really needed
  to understand ordinary TGA images. To not make this chapter a
  complete rip-off of the TGA specification
  \cite{91:_truev_tga_file_format_specif} I will only cover the
  features that are required to load the color data out of the
  image. The rest of the features of the TGA format are free for you
  to explore. And also, the source code for the demo TGA dumper, found
  in \path|code/tga|, will be covering several of these more unusual
  features, but not all of them.

  \section{Some Terminology}

  The TGA format consists things called fields\index{field}. A field
  gives information about the image you're trying to open. It could
  give information like the name of the image, color depth, all the
  color data of the image and so on. It could really contain of
  anything. A field also often has a specific size. The size
  information is of course essential to load a TGA file,otherwise
  you'd not know how the big the respective fields are that you are
  supposed to load.

  \newcommand{\plural}[3]{\ifstrequal{#1}{1}{#2}{#3}}
  \newcommand{\fieldlength}[1]{\ifstrequal{#1}{0}{variable}{#1 \plural{#1}{byte}{bytes}}}
  \newcommand{\imgfield}[2]{\subsection*{#1(\fieldlength{#2})}}
  \newcommand{\imgsubfield}[2]{\subsubsection*{#1(\fieldlength{#2})}}

  We will describe these fields in the order that they occur in their
  respective sections. The separate fields are organized in
  subheadings like this:

  \imgfield{Data}{3}

  This subheading specifies that we will be discussing a field named
  Data that has a length of 3 bytes.

  On the other hand, the subheading:

  \imgfield{Name}{0}

  Shows that we will be covering a field named Name with a length that
  varies depending on the image we're dealing with. The color data
  field is an perfect example of this; it just contains all the color
  data of the image, it thus is obvious that it would vary with the
  size, width, height and color depth of the image in question. The
  sizes of these fields could also be specified in earlier fields, as
  we soon will see an example of.

  The fields are organized into \textit{sections}\index{section} in
  the image format. We will now be covering these sections one after
  one:

  \section{File Header}

  \imgfield{ID Length\index{ID Length}}{1}

  Surprisingly enough, this is one the few image formats that doesn't
  have a set of magic numbers at the beginning. Instead, something
  known as the ID Length of the image is used. In a later field of the
  format, there is a field called the image ID. This field specifies
  the length of that field. It is discussed in depth in section
  \ref{sec:color-data}.

  \imgfield{Color Map Type\index{Color Map Type}}{1}

  The TGA format supports color palettes. An alternative term for a
  palette is Color map\index{color map}. This field could simply be
  seen as a boolean value indicating whether or not the image has a color
  map or not. So if it is $1$, there is a color map in the
  image, otherwise; there's no color map is used.

  \imgfield{Image Type\index{Image Type}}{1}

  There are several ways of storing color as we talked about in
  chapter \ref{cha:color}. In the TGA format there's
  pseudo-color\index{pseudo-color}, which means that the color data
  uses a palette and there's true-color\index{true-color}, meaning that the raw
  color data is stored in the image. And furthermore, the color data
  may either be stored in RGB values, grayscale values and the data
  may even be compressed.

  In the end, this all amounts to $6$ different kinds of images. The
  image type is specified by the number value of this field. Table \ref{tab:imgtype}
  shows all of these different kinds of images. If you have been
  reading carefully up to this point, all the terms of the table
  should make perfect sense to you.

  \begin{table}
    \centering
    \begin{tabular}{ll}
      \toprule
      Image Type & Properties \\
      \midrule
      1 & Uncompressed, Color-mapped \\
      2 & Uncompressed, True-color \\
      3 & Uncompressed, Grayscale\\
      9 & Run-length encoded, Color-mapped \\
      10 & Run-length encoded, True-color \\
      11 & Run-length encoded, Grayscale\\
      \bottomrule
    \end{tabular}
    \caption{Image Type}
    \label{tab:imgtype}
  \end{table}

  From table \ref{tab:imgtype} we can derive the simple algorithm
  \ref{alg:tga-compressed} for determining whether an image is
  compressed.

  \begin{algorithm}[H]
    \caption{Determining if a TGA image is compressed or not.}
    \label{alg:tga-compressed}
    \begin{algorithmic}[1]
      \Let{$compressed$}{$imageType = 9 \OR imageType = 10 \OR
        imageType = 11$}
    \end{algorithmic}
  \end{algorithm}

  \imgfield{Color Map Specification\index{Color Map Specification}}{5}

  The color map specification fields consists of a bunch of subfields
  describing the color map include in this image. If the image doesn't
  even have color map to begin with, these fields will be totally
  useless to you, but on to the subject:

  \imgsubfield{First Entry Index\index{First Entry Index}}{2}

  You could theoretically start anywhere in a color map. But this
  field specified the color will start. It is counter in bytes from
  the beginning of the file. The \textproc{Seek} is used for moving
  the file the first index of the color map in this case. And most
  programming languages have an equivalent to this functions for
  reading files.

  \imgsubfield{Color map length\index{Color map length}}{2}

  In this field, the length of the color map is specified(duh!)

  \imgsubfield{Color map entry size\index{Color map entry size}}{1}

  Because the color map is just an array of colors, of course these
  colors must have some sort of color depth. That color depth is
  specified by this field.

  \imgfield{Image Specification\index{Image Specification}}{10}

  Following the color map specification is the image specification,
  specifying other, miscellaneous, properties of an image useful for
  loading it.

  \imgsubfield{X-origin of Image}{2}

  \imgsubfield{Y-origin of Image}{2}

  The position of the image on the screen.

  \imgsubfield{Image Width\index{Image Width}}{2}

  \imgsubfield{Image Height\index{Image Height}}{2}

  These two fields specify the measurements of the image in pixels.

  \imgsubfield{Pixel Depth\index{Pixel Depth}}{1}

  Even if the image includes a color palette, this field would still
  be very important. Because the image in that is just a bunch of
  indices, they could still have a depth, or size as would be more
  conventient to say in this case.

  \imgsubfield{Image Descriptor\index{Image Descriptor}}{1}

  Describes the image and bla.

  \section{Loading the file header}
  \label{sec:loading-file-header}

  These fields occur in the order that I just described
  them. Algorithm ref{alg:load-file-header} shows how to load them. The values of these fields
  will be used in the loading code for the color data, so do take note
  of their names. As can be seen, I'm almost being condescending
  towards you by even bothering to include this extremely simple
  code. I promise I won't be as condescending in the future.

  \begin{algorithm}
    \caption{Loading the file header of a TGA image.}
    \label{alg:load-file-header}
    \newcommand{\loadfield}[2]{\Let{$#1$}{\Call{Read}{$#2$}}}
    \begin{algorithmic}[1]
      \loadfield{IDLength}{1}
      \loadfield{colorMapType}{1}
      \loadfield{imageType}{1}
      \linecomment{The Color Map Specification}
      \loadfield{colorMapOffset}{2}
      \loadfield{colorMapLength}{2}
      \loadfield{colorMapEntrySize}{2}
      \linecomment{Image Specification}
      \loadfield{xOrigin}{2}
      \loadfield{yOrigin}{2}
      \loadfield{imageWidth}{2}
      \loadfield{imageHeight}{2}
      \loadfield{pixelDepth}{1}
      \loadfield{imageDescriptor}{1}
    \end{algorithmic}
  \end{algorithm}

  \section{Color Data\index{Color Data}}
  \label{sec:color-data}

  Here's where the fun part starts!

  \imgfield{Image ID\index{Image ID}}{0}

  This field contains identifying information about the image. The
  ID Length field found in the header is the length of this field. If
  the ID Length is 0, this field doesn't exist. This field is an ASCII
  string.

  \imgfield{Color Map Data\index{Color Map Data}}{0}

  Loading the color map is easy, as shown in algorithm
  \ref{alg:read-colormap}. \todo{deal with color map entry index}. You
  biggest worry is that you might forgot to divide the pixel depth by
  8, as it is measured in bits and \textit{not bytes}.

  \begin{algorithm}[H]
    \caption{Reading the color map of a TGA file.}
    \label{alg:read-colormap}
    \begin{algorithmic}[1]
      \ForTo{$i$}{$0$}{$colorMapLength$}
        \Let{$data$}{\Call{Read}{$pixelDepth / 8$}}
        \Let{$colorMap[i]$}{$data$}
      \EndFor
    \end{algorithmic}
  \end{algorithm}

  \imgfield{Color Data\index{Color Data}}{0}

  Here we have true ``meat and blood'' of the TGA format. In this
  field the color data of the image is stored. The way this data is
  stored depends on the image type. We'll be using the $compressed$
  variable we created in algorithm \ref{alg:tga-compressed}.

  \begin{algorithm}[H]
    \caption{Reading the color data of a TGA file.}
    \label{alg:TGA-read-colordata}
    \newcommand{\process}{\State Process the color $data$ \dots}
    \begin{algorithmic}[1]
      \Let{$length$}{$imageWidth \mul imageHeigth$}
      \Let{$i$}{$0$}
      \While{$i < length$}
        \If{$compressed$}

          \Let{$head$}{\VoidCall{ReadByte}}
          \Let{$length$}{$head \BitAnd 127$}

          \If{$head \BitAnd 128$}

            \Let{$data$}{$pixelDepth / 8$}

            \If{colorMapType}
              \Let{$data$}{colorMap[data]}
            \EndIf

            \Repeatn{length}

              \process

              \Inc{$i$}{$1$}

            \EndRepeatn

          \Else

            \Repeatn{length}

              \Let{$data$}{$pixelDepth / 8$}

              \If{colorMapType}
                \Let{$data$}{$colorMap[data]$}
              \EndIf

              \process

              \Inc{$i$}{$1$}

            \EndRepeatn

          \EndIf
        \Else

          \Let{$data$}{\Call{Read}{pixelDepth / 8}}

          \If{colorMapType}
            \Let{$data$}{colorMap[data]}
          \EndIf

          \process

          \Inc{$i$}{$1$}

        \EndIf
      \EndWhile
    \end{algorithmic}
  \end{algorithm}

  Most of the algorithm should already be familiar to you.

  \section{Developer Area\index{Developer Area}}

  The extension area is useful to programmers.

  \section{Extension Area\index{Extension Area}}

  The extension area includes many different fields containing mostly
  miscellaneous information about an image. We will not be covering
  here, but the sample source code includes does load this area and
  all of it's fields. See the TGA specification for more information
  on this area.

  \section{TGA File Footer\index{File Footer}}

  The file footer of a TGA image always occurs in the end of it, if it
  has one. Images made before the version 2 of the TGA format tend not
  to have one, and neither do they have an extension area nor
  developer area. Speaking of that, all this section really contains
  is the offset the developer area and extension area. \todo{mention
    the fseek function}. Because you see, these fields can occur
  anywhere in a TGA image.\todo{mention order implications}.

  what.

  \printbibliography[heading=subbibliography]

\end{refsection}