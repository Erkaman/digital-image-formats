\begin{comment}
  \bibliography{project.bib}
\end{comment}

\chapter{\tga{} -- Truevision Graphics Adapter}
\label{cha:tga}

\begin{refsection}

  \section{Introduction}
  \label{sec:tga-introduction}

  The  purpose of this whole book was to give a good understanding of
  how image formats really work under the hood. But we couldn't just
  have jumped right in, we required knowledge of how color is stored
  digitally and how compression algorithms work. Now it's time to put
  that knowledge to good use.

  That's right, we are finally going to explore our first \textit{real} image format:
  \tga\index{TGA}. But why \tga of all image formats? Because the
  format is an extremely simple one at that, yet it is actually widely
  used in certain areas, like games and video processing. It has all
  the parts common to all image formats and features a very simple
  compression algorithm: PackBits RLE, which was one of the algorithms
  we covered in chapter \ref{cha:compress-techn}.

  But the \tga format is also has its share of complexity. To make the
  format more easily extensible by programmers, several features were
  added in the second version of the format, which is the version we
  are going to cover. But we will only mention and not explain these
  features, as they are not really needed to load the color data
  stored in \tga images.

  The source code accompanying this chapter is a \tga dumper. All this
  program really do is load the color right out of a \tga file and
  dump it is as raw ASCII strings on the form \verb|(R,G,B)|. It will
  also dump information about the image, like color depth and image
  width.  This dumper will cover several of the features \textit{not}
  covered in this chapter, so please have a peek at the source code of
  this program if you hunger for more information about the \tga
  format.

  And if you want to know very detailed information about the TGA
  format, then you should most definitely read the \tga specification:
  \cite{91:_truev_tga_file_format_specif}.

  \section{Some Terminology}

  The \tga format consists things called fields\index{field}. A field
  gives information about the image you're trying to open. It could
  give information like the name of the image, color depth, all the
  color data of the image and so on. It could really contain any sort
  of data.

  A field also often has a specific size. Knowing the size of a field
  is course essential to loading its data, since you cannot just let
  the computer guess the size of a field. It's all just a long sequence
  of numbers to the computer, so you as the programmer will have to
  tell the computer how big the respective fields are in order to load
  them.

  \newcommand{\plural}[3]{\ifstrequal{#1}{1}{#2}{#3}}
  \newcommand{\fieldlength}[1]{\ifstrequal{#1}{0}{variable}{#1 \plural{#1}{byte}{bytes}}}
  \newcommand{\imgfield}[2]{\subsection*{#1(\fieldlength{#2})}}
  \newcommand{\imgsubfield}[2]{\subsubsection*{#1(\fieldlength{#2})}}

  Fields are organized into larger units known as
  \textit{sections}\index{section}. We will in this chapter cover
  these sections one after one and we will describe the fields in the
  order that they occur in their respective sections. The separate
  fields are organized in subheadings like this:

  \imgfield{Data}{3}

  This subheading specifies that we will be discussing a field named
  Data that has a size of 3 bytes.

  On the other hand, the subheading:

  \imgfield{Name}{0}

  Shows that we will be covering a field named Data with a variable
  size.That is, the size varies depending on the image we're
  dealing with. The color data field is an perfect example of this; it
  just contains all the color data of the image, it is thus obvious
  that it would vary with the size, width, height and color depth of
  the specific image we're dealing with. The sizes of these fields
  could also be specified in \textit{earlier} fields, as we soon will see an
  example of.

  \section{The File Header}

  \imgfield{ID Length\index{ID Length}}{1}

  Surprisingly enough, this is one the few image formats that doesn't
  have a set of magic numbers at the beginning. Instead, something
  known as the ID Length of the image occurs in the beginning. In a
  later field of the format, there is a field called the image
  ID and this field specifies the size of that field. It is discussed
  in depth in section \ref{sec:color-data}.

  \imgfield{Color Map Type\index{Color Map Type}}{1}

  The \tga format supports color palettes. An alternative term for a
  palette is Color map\index{color map}. This field could simply be
  seen as a boolean value indicating whether or not the image has a
  color map. So if it the value of this field is $1$, the image uses a
  color map, otherwise; there's no color map.

  \imgfield{Image Type\index{Image Type}}{1}

  The \tga format allows three different ways of storing color:
  grayscale\index{grayscale}, color-mapped\index{color-mapped} and
  true-color\index{true-color}.

  Grayscale should be familiar to you by now. Color-mapped color
  obviously means that the color uses a color-map. But what on earth
  could true-color be? This simply means that it uses the RGB or RGBA
  color models. The color depths supported by the \tga format are
  16,24 and 32.

  Since the color data can also be compressed, this all amounts to $6$
  different kinds of images. The image type is specified by the number
  value of this field. Table \ref{tab:imgtype} shows all the different
  number value's respective image type.

  \begin{table}
    \centering
    \begin{tabular}{ll}
      \toprule
      Image Type & Properties \\
      \midrule
      1 & Uncompressed, Color-mapped \\
      2 & Uncompressed, True-color \\
      3 & Uncompressed, Grayscale\\
      9 & Run-length encoded, Color-mapped \\
      10 & Run-length encoded, True-color \\
      11 & Run-length encoded, Grayscale\\
      \bottomrule
    \end{tabular}
    \caption{Image Type}
    \label{tab:imgtype}
  \end{table}

  From table \ref{tab:imgtype}, we can derive the simple algorithm
  \ref{alg:tga-compressed} for determining whether an image is
  compressed.

  \begin{algorithm}[H]
    \caption{Determining if a \tga image is compressed or not.}
    \label{alg:tga-compressed}
    \begin{algorithmic}[1]
      \Let{$compressed$}{$imageType = 9 \OR imageType = 10 \OR
        imageType = 11$}
    \end{algorithmic}
  \end{algorithm}

  \imgfield{Color Map Specification\index{Color Map Specification}}{5}

  The color map specification fields consists of a bunch of subfields
  describing the color map included in the image. If the image
  doesn't even have a color map to begin with, these fields can simply
  be ignored. Let us describe these subfields one after one

  \imgsubfield{First Entry Index\index{First Entry Index}}{2}

  A color map essentially consists of a sequence of colors. The value
  of this field is how many of those colors that should be skipped in
  the beginning of that sequence. Don't know why you'd \textit{ever}
  want to do this, though.

  \imgsubfield{Color map length\index{Color map length}}{2}

  In this field, the length of the color map is specified. The
  length is the number of colors in the color map.

  \imgsubfield{Color map entry size\index{Color map entry size}}{1}

  Because the color map is just an array of colors, of course all
  these colors must have a specific color depth. That color depth is
  specified by this field.

  \imgfield{Image Specification\index{Image Specification}}{10}

  Following the color map specification is the image specification,
  specifying other, miscellaneous, properties of an image useful for
  loading it.

  \imgsubfield{X-origin of Image}{2}

  \imgsubfield{Y-origin of Image}{2}

  The position of the image on the screen.

  \imgsubfield{Image Width\index{Image Width}}{2}

  \imgsubfield{Image Height\index{Image Height}}{2}

  These two fields specify the measurements of the image in pixels.

  \imgsubfield{Pixel Depth\index{Pixel Depth}}{1}

  This is just the color depth of the image and this concept should
  hopefully be nothing new to you.

  If the image uses a color palette, this field just specifies the
  size of the number indices that the image in that case consists of.

  \imgsubfield{Image Descriptor\index{Image Descriptor}}{1}

  The image desciptor is an interesting,albeit useless field. It is a
  single byte whose values are structured in the way in figure
  \ref{fig:tga-image-desc}. As can be seen, the two highest
  bits are unused and should be ignored. They are always zero.

  \begin{figure}[H]
    \centering
    \inputtikz{tga_image_descriptor}
    \caption{Image descriptor}
    \label{fig:tga-image-desc}
  \end{figure}

  The next two bytes are a bit more insetting. Basically, they specify
  the from where the start of the displays of the pixels on screen
  should start.

  \begin{table}
    \centering
    \begin{tabular}{lrr}
      \toprule
      Screen destination \\ of first pixel & bit 5 & bit 4 \\
      \midrule
      bottom left & 0 & 0 \\
      bottom right & 0 & 1 \\
      top left & 1 & 0 \\
      top right & 1 & 1 \\
      \bottomrule
    \end{tabular}
    \caption{The different image origin combinations}
    \label{tab:image-origin}
  \end{table}

  The last four bits are the alpha channel bits. These specify how
  many bits in a separate color is used for the alpha channel. For
  images without an alpha channel this value will of course be
  zero. For 16-bit images it will be 1, and for 32-bit images it will
  be 8.

  These fields occur in the order that I just described
  them. Algorithm \ref{alg:load-file-header} shows how to load them. The values of these fields
  will be used in the loading code for the color data, so do take note
  of their names. As can be seen, I'm almost being condescending
  towards you by even bothering to include this extremely simple
  code. I promise I won't be as condescending in the future.

  \begin{algorithm}
    \caption{Loading the file header of a \tga image.}
    \label{alg:load-file-header}
    \newcommand{\loadfield}[2]{\Let{$#1$}{\Call{Read}{$#2$}}}
    \begin{algorithmic}[1]
      \loadfield{IDLength}{1}
      \loadfield{colorMapType}{1}
      \loadfield{imageType}{1}
      \linecomment{The Color Map Specification}
      \loadfield{colorMapOffset}{2}
      \loadfield{colorMapLength}{2}
      \loadfield{colorMapEntrySize}{2}
      \linecomment{Image Specification}
      \loadfield{xOrigin}{2}
      \loadfield{yOrigin}{2}
      \loadfield{imageWidth}{2}
      \loadfield{imageHeight}{2}
      \loadfield{pixelDepth}{1}
      \loadfield{imageDescriptor}{1}
    \end{algorithmic}
  \end{algorithm}

  But parsing the data from the image descriptor is not as easy.

  Let us first consider how to parse the image origin data.The fifth
  bit of a binary number has be value $1 \ShiftLeft 5$, thus we can
  get the value of the fifth bit of the image descriptor with the
  operation $(1 \ShiftLeft 5) \BitAnd imageDescriptor$. In the same
  way the value of the 4:th bit is $(1 \ShiftLeft 4) \BitAnd
  imageDescriptor$. Then, we can match these bit values with the
  description of table \ref{tab:image-origin}.

  For extracting the alpha channel bits we will need to do something a
  bit more complex. To match for the first fours bits, we need the
  binary number 00001111, then we'd get the alpha channel bits though
  the following operation:

  \begin{center}
    \begin{tabular}{*{4}{c}}
      & 01010010 & (example number) \\
      $\BitAnd$ & 00001111 & \\
      \cline{1-2}
      &  00000010 \\
    \end{tabular}
  \end{center}

  00001111 is simply the value $1 + 2 + 4 + 8 = 15$. Thus we are able
  to extract the alpha channel bits through algorithm
  \ref{alg:tga-alpha-channel-bits}.

  \begin{algorithm}[H]
    \caption{Getting the alpha channel bits out of the image descriptor.}
    \label{alg:tga-alpha-channel-bits}
    \begin{algorithmic}[1]
      \Let{$alphaChannelBits$}{$imageDescriptor \BitAnd 15$}
    \end{algorithmic}
  \end{algorithm}


  % Being able to exact ranges of bits out of number is quite useful
  % operation, so let us make a function out of it.

  \section{Color Data\index{Color Data}}
  \label{sec:color-data}

  Here's where the fun part starts!

  \imgfield{Image ID\index{Image ID}}{0}

  This field contains identifying information about the image. The
  ID Length field found in the header is the length of this field. If
  the ID Length is 0, this field doesn't exist. This field is an ASCII
  string.

  \imgfield{Color Map Data\index{Color Map Data}}{0}

  Loading the color map is easy, as shown in algorithm
  \ref{alg:read-colormap}. You
  biggest worry is that you might forgot to divide the pixel depth by
  8, as it is measured in bits and \textit{not bytes}.

  \begin{algorithm}[H]
    \caption{Reading the color map of a \tga file.}
    \label{alg:read-colormap}
    \begin{algorithmic}[1]
      \State \Call{$Seek$}{$colorMapStart,CURRENT$}
      \ForTo{$i$}{$colorMapStart$}{$colorMapLength$}
        \Let{$data$}{\Call{Read}{$pixelDepth / 8$}}
        \Let{$colorMap[i]$}{$data$}
      \EndFor
    \end{algorithmic}
  \end{algorithm}

  \imgfield{Color Data\index{Color Data}}{0}

  Here we have true ``meat and blood'' of the \tga format. In this
  field, the color data of the image is stored. The way this data is
  stored depends on the image type. We'll be using the $compressed$
  variable we created in algorithm \ref{alg:tga-compressed}.

  \begin{algorithm}[H]
    \caption{Reading the color data of a \tga file.}
    \label{alg:TGA-read-colordata}
    \newcommand{\process}{\State Process the color $data$ \dots}
    \begin{algorithmic}[1]
      \Let{$length$}{$imageWidth \mul imageHeigth$}
      \Let{$i$}{$0$}
      \While{$i < length$}
        \If{$compressed$}

          \Let{$head$}{\VoidCall{ReadByte}}
          \Let{$length$}{$head \BitAnd 127$}

          \If{$head \BitAnd 128$}

            \Let{$data$}{$pixelDepth / 8$}

            \If{colorMapType}
              \Let{$data$}{colorMap[data]}
            \EndIf

            \Repeatn{length}

              \process

              \Inc{$i$}{$1$}

            \EndRepeatn

          \Else

            \Repeatn{length}

              \Let{$data$}{$pixelDepth / 8$}

              \If{colorMapType}
                \Let{$data$}{$colorMap[data]$}
              \EndIf

              \process

              \Inc{$i$}{$1$}

            \EndRepeatn

          \EndIf
        \Else

          \Let{$data$}{\Call{Read}{pixelDepth / 8}}

          \If{colorMapType}
            \Let{$data$}{colorMap[data]}
          \EndIf

          \process

          \Inc{$i$}{$1$}

        \EndIf
      \EndWhile
    \end{algorithmic}
  \end{algorithm}

  Most of the algorithm should already be familiar to you.

  \section{Developer Area\index{Developer Area}}

  The extension area is really only useful to programmers. It allows
  programmers to add information to the \tga format that is specific
  to their applications. But this information is useless if you're
  only trying to load the color data from the \tga image, hence why we
  are no talking in more detail about this section. If you have
  actually found a \tga image out in the wild that uses this
  section, you can only really guess how you are supposed to use this
  data, as this is entirely dependent on the source program of the image.

  \section{Extension Area\index{Extension Area}}

  The extension area is a huge section containing many different
  fields that gives a lot of miscellaneous information about an
  image. As they are all essentially trivial to load, we will not be
  covering them here, but the sample \tga dumper does indeed load this
  section and all of it's fields. See the source code to that program and
  the \tga specification for more information on this area.

  \section{File Footer\index{File Footer}}

  The file footer of a \tga image always occurs at the end of it. But
  not all \tga images have a file footer, however. Images made before
  the version 2 of the \tga format do \textit{not} have one, and
  neither do they have an extension area nor a developer area. Because
  all information that the file footer really includes is the
  \textit{location} of the developer and extension area. These are two
  fields that can occur anywhere in a \tga image, except for in the
  beginning and the end of the image, that is why this location
  information is included with the file footer.

  \printbibliography[heading=subbibliography]

\end{refsection}