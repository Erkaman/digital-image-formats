\begin{comment}
  \bibliography{project.bib}
\end{comment}

% TODO: describe the seek Seek functions and it's options carefully.
\chapter{\tga -- Truevision Graphics Adapter}
\label{cha:tga}

\begin{refsection}

  \section{Introduction}
  \label{sec:tga-introduction}

  The whole purpose of this book was to give a good understanding of
  how image formats really work under the hood. But we couldn't just
  have jumped right in, we required knowledge of how color is stored
  digitally and how compression algorithms work. Now it's time to put
  that knowledge to good use. \textit{All} the compression algorithms
  we have just covered are used in the image formats we are going to
  explore. And of course, knowledge how color is stored digitally is
  going to be purely essential to go on.

  Now it's time to explore our real first image format:
  \tga\index{TGA}. But why \tga of all image formats? Because the format
  is an extremely simple one at that, yet it is actually widely used
  in certain areas, like games and video processing. And it has all
  the parts common to all image formats and it even features a very
  simple compression algorithm: PackBits RLE, which was one of the
  algorithms we covered in chapter \ref{cha:compress-techn}.

  But the \tga format is also has its share of complexity. To make the
  format more extensible for programmers such as us, several features
  were added in the second version of the format. But we will only
  mention but not explain these features as they are not really needed
  to understand ordinary \tga images. To not make this chapter a
  complete rip-off of the \tga specification
  \cite{91:_truev_tga_file_format_specif} I will only cover the
  features that are required to load the color data out of the
  image. The rest of the features of the \tga format are free for you
  to explore. And also, the source code for the demo \tga dumper, found
  in \path|code/tga|, will be covering several of these more unusual
  features, but not all of them.

  \section{Some Terminology}

  The \tga format consists things called fields\index{field}. A field
  gives information about the image you're trying to open. It could
  give information like the name of the image, color depth, all the
  color data of the image and so on. It could really contain of
  anything. A field also often has a specific size. The size
  information is of course essential to load a \tga file,otherwise
  you'd not know how the big the respective fields are that you are
  supposed to load.

  \newcommand{\plural}[3]{\ifstrequal{#1}{1}{#2}{#3}}
  \newcommand{\fieldlength}[1]{\ifstrequal{#1}{0}{variable}{#1 \plural{#1}{byte}{bytes}}}
  \newcommand{\imgfield}[2]{\subsection*{#1(\fieldlength{#2})}}
  \newcommand{\imgsubfield}[2]{\subsubsection*{#1(\fieldlength{#2})}}

  We will describe these fields in the order that they occur in their
  respective sections. The separate fields are organized in
  subheadings like this:

  \imgfield{Data}{3}

  This subheading specifies that we will be discussing a field named
  Data that has a length of 3 bytes.

  On the other hand, the subheading:

  \imgfield{Name}{0}

  Shows that we will be covering a field named Name with a length that
  varies depending on the image we're dealing with. The color data
  field is an perfect example of this; it just contains all the color
  data of the image, it thus is obvious that it would vary with the
  size, width, height and color depth of the image in question. The
  sizes of these fields could also be specified in earlier fields, as
  we soon will see an example of.

  The fields are organized into \textit{sections}\index{section} in
  the image format. We will now be covering these sections one after
  one:

  \section{File Header}

  \imgfield{ID Length\index{ID Length}}{1}

  Surprisingly enough, this is one the few image formats that doesn't
  have a set of magic numbers at the beginning. Instead, something
  known as the ID Length of the image occurs in the beginning. In a
  later field of the format, there is a field called the image
  ID and this field specifies the length of that field. It is discussed
  in depth in section \ref{sec:color-data}.

  \imgfield{Color Map Type\index{Color Map Type}}{1}

  The \tga format supports color palettes. An alternative term for a
  palette is Color map\index{color map}. This field could simply be
  seen as a boolean value indicating whether or not the image has a color
  map or not. So if it is $1$, there is a color map in the
  image, otherwise; there's no color map.

  \imgfield{Image Type\index{Image Type}}{1}

  In the \tga format color can be stored in three different ways:
  grayscale\index{grayscale}, color-mapped\index{color-mapped} and
  true-color\index{true-color}.

  Grayscale should be familiar to you by now. Color-mapped color
  basically means that the color uses a palette, or color-map as it is
  also called. But what on earth could true-color be? This means that
  it uses RGB or RGBA color storage. The possible color depths are
  16,24 and 32, as talked about in chapter \ref{cha:color}.

  Since the color data can also be compressed, in the end this all
  amounts to $6$ different kinds of images. The image type is
  specified by the number value of this field. Table \ref{tab:imgtype}
  shows all of these different kinds of images.

  \begin{table}
    \centering
    \begin{tabular}{ll}
      \toprule
      Image Type & Properties \\
      \midrule
      1 & Uncompressed, Color-mapped \\
      2 & Uncompressed, True-color \\
      3 & Uncompressed, Grayscale\\
      9 & Run-length encoded, Color-mapped \\
      10 & Run-length encoded, True-color \\
      11 & Run-length encoded, Grayscale\\
      \bottomrule
    \end{tabular}
    \caption{Image Type}
    \label{tab:imgtype}
  \end{table}

  From table \ref{tab:imgtype}, we can derive the simple algorithm
  \ref{alg:tga-compressed} for determining whether an image is
  compressed.

  \begin{algorithm}[H]
    \caption{Determining if a \tga image is compressed or not.}
    \label{alg:tga-compressed}
    \begin{algorithmic}[1]
      \Let{$compressed$}{$imageType = 9 \OR imageType = 10 \OR
        imageType = 11$}
    \end{algorithmic}
  \end{algorithm}

  \imgfield{Color Map Specification\index{Color Map Specification}}{5}

  The color map specification fields consists of a bunch of subfields
  describing the color map included in this image. If the image
  doesn't even have color map to begin with, these fields can simply
  be ignored. Let us describe these subfields one after one

  \imgsubfield{First Entry Index\index{First Entry Index}}{2}

  A color map essentially consists of sequence of color. The value of
  this field is how many of those color that should be skipped in the
  beginning. Don't know why you'd \textit{ever} want to do this, though.

  \imgsubfield{Color map length\index{Color map length}}{2}

  In this field, the length of the color map is specified(duh!). The
  length is the number of colors in the color map.

  \imgsubfield{Color map entry size\index{Color map entry size}}{1}

  Because the color map is just an array of colors, of course these
  colors must have some sort of color depth. That color depth is
  specified by this field.

  \imgfield{Image Specification\index{Image Specification}}{10}

  Following the color map specification is the image specification,
  specifying other, miscellaneous, properties of an image useful for
  loading it.

  \imgsubfield{X-origin of Image}{2}

  \imgsubfield{Y-origin of Image}{2}

  The position of the image on the screen.

  \imgsubfield{Image Width\index{Image Width}}{2}

  \imgsubfield{Image Height\index{Image Height}}{2}

  These two fields specify the measurements of the image in pixels.

  \imgsubfield{Pixel Depth\index{Pixel Depth}}{1}

  This is just the color depth of the image and this concept should
  hopefully be nothing new to you.

  If the image uses a color palette, this field just specifies the
  size of the number indices that the image in that case consists of.

  \imgsubfield{Image Descriptor\index{Image Descriptor}}{1}

  Describes the image and bla. \ref{fig:tga-image-desc}

  \begin{figure}[H]
    \centering
    \inputtikz{tga_image_descriptor}
    \caption{Image descriptor}
    \label{fig:tga-image-desc}
  \end{figure}

  \section{Loading the file header}
  \label{sec:loading-file-header}

  These fields occur in the order that I just described
  them. Algorithm ref{alg:load-file-header} shows how to load them. The values of these fields
  will be used in the loading code for the color data, so do take note
  of their names. As can be seen, I'm almost being condescending
  towards you by even bothering to include this extremely simple
  code. I promise I won't be as condescending in the future.

  \begin{algorithm}
    \caption{Loading the file header of a \tga image.}
    \label{alg:load-file-header}
    \newcommand{\loadfield}[2]{\Let{$#1$}{\Call{Read}{$#2$}}}
    \begin{algorithmic}[1]
      \loadfield{IDLength}{1}
      \loadfield{colorMapType}{1}
      \loadfield{imageType}{1}
      \linecomment{The Color Map Specification}
      \loadfield{colorMapOffset}{2}
      \loadfield{colorMapLength}{2}
      \loadfield{colorMapEntrySize}{2}
      \linecomment{Image Specification}
      \loadfield{xOrigin}{2}
      \loadfield{yOrigin}{2}
      \loadfield{imageWidth}{2}
      \loadfield{imageHeight}{2}
      \loadfield{pixelDepth}{1}
      \loadfield{imageDescriptor}{1}
    \end{algorithmic}
  \end{algorithm}

  \section{Color Data\index{Color Data}}
  \label{sec:color-data}

  Here's where the fun part starts!

  \imgfield{Image ID\index{Image ID}}{0}

  This field contains identifying information about the image. The
  ID Length field found in the header is the length of this field. If
  the ID Length is 0, this field doesn't exist. This field is an ASCII
  string.

  \imgfield{Color Map Data\index{Color Map Data}}{0}

  Loading the color map is easy, as shown in algorithm
  \ref{alg:read-colormap}. \todo{deal with color map entry index}. You
  biggest worry is that you might forgot to divide the pixel depth by
  8, as it is measured in bits and \textit{not bytes}.

  \begin{algorithm}[H]
    \caption{Reading the color map of a \tga file.}
    \label{alg:read-colormap}
    \begin{algorithmic}[1]
      \State \Call{$Seek$}{$colorMapStart,CURRENT$}
      \ForTo{$i$}{$colorMapStart$}{$colorMapLength$}
        \Let{$data$}{\Call{Read}{$pixelDepth / 8$}}
        \Let{$colorMap[i]$}{$data$}
      \EndFor
    \end{algorithmic}
  \end{algorithm}

  \imgfield{Color Data\index{Color Data}}{0}

  Here we have true ``meat and blood'' of the \tga format. In this
  field, the color data of the image is stored. The way this data is
  stored depends on the image type. We'll be using the $compressed$
  variable we created in algorithm \ref{alg:tga-compressed}.

  \begin{algorithm}[H]
    \caption{Reading the color data of a \tga file.}
    \label{alg:TGA-read-colordata}
    \newcommand{\process}{\State Process the color $data$ \dots}
    \begin{algorithmic}[1]
      \Let{$length$}{$imageWidth \mul imageHeigth$}
      \Let{$i$}{$0$}
      \While{$i < length$}
        \If{$compressed$}

          \Let{$head$}{\VoidCall{ReadByte}}
          \Let{$length$}{$head \BitAnd 127$}

          \If{$head \BitAnd 128$}

            \Let{$data$}{$pixelDepth / 8$}

            \If{colorMapType}
              \Let{$data$}{colorMap[data]}
            \EndIf

            \Repeatn{length}

              \process

              \Inc{$i$}{$1$}

            \EndRepeatn

          \Else

            \Repeatn{length}

              \Let{$data$}{$pixelDepth / 8$}

              \If{colorMapType}
                \Let{$data$}{$colorMap[data]$}
              \EndIf

              \process

              \Inc{$i$}{$1$}

            \EndRepeatn

          \EndIf
        \Else

          \Let{$data$}{\Call{Read}{pixelDepth / 8}}

          \If{colorMapType}
            \Let{$data$}{colorMap[data]}
          \EndIf

          \process

          \Inc{$i$}{$1$}

        \EndIf
      \EndWhile
    \end{algorithmic}
  \end{algorithm}

  Most of the algorithm should already be familiar to you.

  \section{Developer Area\index{Developer Area}}

  The extension area is useful to programmers. It allows program add
  information to the \tga format that is specific to their
  applications. But this information is useless if you're only trying
  to load the color data from the \tga image, hence why we are no
  talking in more detail about this section. If you have found an
  \tga image out in the wild that actually uses this, you can really
  guess how you are supposed to use this data, so you can't really
  load it properly.

  \section{Extension Area\index{Extension Area}}

  The extension area is a huge section containing many different
  fields that gives a lot of miscellaneous information about an
  image. As they are essentially trivial to load, we will not be
  covering them here, but the sample \tga dumper does does load this
  area and all of it's fields. See the source code to that program and
  the \tga specification for more information on this area.

  \section{\tga File Footer\index{File Footer}}

  The file footer of a \tga image always occurs in the end of it. But
  not all \tga images have a file footer, however. Images made before
  the version 2 of the \tga format tend not to have one, and neither
  do they have an extension area nor a developer area. Because all
  information that the file footer really includes is the location of
  the developer and extension area. These are two fields that can
  really occur anywhere in a \tga image, except for in the beginning
  and the end of the image, that is why the location information is
  included.

  \printbibliography[heading=subbibliography]

\end{refsection}