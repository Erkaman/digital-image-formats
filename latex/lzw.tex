\begin{comment}
  \bibliography{project.bib}
\end{comment}

\chapter{LZW}
\label{ch:rle}

\begin{refsection}

In this chapter we will discuss the data compression algorithm \lzw\index{LZW} as
it is described in
\cite{nelson89:_lzw_data_compr,Welch:1984:THD:1319729.1320134,Salomon:2004:DCC}

\section{Compression algorithm}

\subsection{Description}

The \lzw compression\index{\lzw compression} algorithm is best
understood by walking through the LZW algorithms process of
compressing some sample data. Let's we want to compress the string
\texttt{ababcbababaaaaaaa}.

First we will fill a string table\index{string table} containing all
the numbers possible in byte, from 0 to 255, and their corresponding
letters as is shown in table \ref{tab:str-tab-ascii}. We will from now
on refer to these numbers as number codes\index{number code}, or
simply codes\index{code}.

\newcommand{\dotsrow}{\dots & \dots \\}
\newcommand{\strrow}[2]{$#1$ & #2 \\}

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    String & Code \\
    \midrule

    \dotsrow
    \strrow{33}{!}
    \strrow{34}{"}
    \strrow{35}{\#}
    \dotsrow
    \strrow{97}{a}
    \strrow{98}{b}
    \strrow{99}{c}
    \dotsrow
    \strrow{255}{}

    \bottomrule
  \end{tabular}
  \caption{The initial LZW string table}
  \label{tab:str-tab-ascii}
\end{table}

Now let's go through the sample string. First we read the first
character \texttt{a}. If we look up this letter in the table we get
the number code $97$, so we just output this code. Next, we read in
the character \texttt{b}, which has the number $98$. We first output
the code of b, $98$, and then we append the two up until now read
characters together, and get the string \texttt{ab}. After this we
check if this string exists in the string table. If we inspect table
\ref{tab:str-tab-ascii}, we soon realize that the string is
\textit{not} in the table. So the string is added to the table and it
is assigned to the next available code, $256$.

\texttt{a} is discarded, we keep \texttt{b} and we read in another
\texttt{a}. First we output \texttt{b}, but however this time, we end with the appended string
\texttt{ba}. This string doesn't either exist in the table and so we
add it with the code $257$. We throw away \texttt{b}, output
\texttt{a} and read in another \texttt{b}. Now something very
interesting thing happens; The appended string we end up with is this
time \texttt{ab}. But wait a minute, haven't we already added that
string to the string table? Yes, we have, so instead of re-adding that
string to table, we output its code, $256$. This means we instead
separately adding the codes of \texttt{a} and \texttt{b}, we just
output one single code! In the next step the algorithm, we will
let the appended string \texttt{ab} represent the former character.

So we output the single code for \texttt{ab}.  And then we read in the
character \texttt{c}. The string \texttt{abc} doesn't exist in the
table, so we give it the code $258$ and it just keeps going like
this. Table \ref{tab:str-tab-str} shows the codes that were added during the compression
of the string. Table \ref{tab:lzw-walkthru} gives a detailed walkthrough of the compression
of the string, do study this table carefully and don't go on reading
until you fully understand it.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    String & Code \\
    \midrule

    \dotsrow
    \strrow{256}{ab}
    \strrow{257}{ba}
    \strrow{258}{abc}
    \strrow{259}{cb}
    \strrow{260}{bab}
    \strrow{261}{baba}
    \strrow{262}{aa}
    \strrow{263}{aaa}
    \strrow{264}{aaaa}
    \bottomrule
  \end{tabular}
  \caption{The string table after the \lzw algorithm has been run.}
  \label{tab:str-tab-str}
\end{table}

\begin{table}
  \centering
  \newcommand{\lzwrow}[4]{#1 & #2 & #3 & #4 \\}
  \begin{tabular}{llll}
    \toprule
    String Code & New Code & Output Code & New table entry \\
    \midrule

    \lzwrow{a}{b}{a = 97}{ab = 256}
    \lzwrow{b}{a}{b = 98}{ba = 257}
    \lzwrow{a}{b}{}{}
    \lzwrow{ab}{c}{ab = 256}{abc = 258}
    \lzwrow{c}{b}{c = 99}{cb = 259}
    \lzwrow{b}{a}{}{}
    \lzwrow{ba}{b}{ba = 257}{bab = 260}
    \lzwrow{b}{a}{}{}
    \lzwrow{ba}{b}{}{}
    \lzwrow{bab}{a}{bab = 260}{baba = 260}
    \lzwrow{a}{a}{a = 97}{aa = 261}
    \lzwrow{a}{a}{}{}
    \lzwrow{aa}{a}{aa = 262}{aaa = 262}
    \lzwrow{a}{a}{}{}
    \lzwrow{aa}{a}{}{}
    \lzwrow{aaa}{a}{aaa = 263}{aaaa = 263}

    \bottomrule
  \end{tabular}
  \caption{LZW control flow.}
  \label{tab:lzw-walkthru}
\end{table}

3\subsection{Algorithm}

\ref{alg:lzw-compression}


\begin{algorithm}[H]
  \caption{Settings the constants for the LZW algorithm}
  \label{alg:lzw-constants}
  \begin{algorithmic}[1]
    \Let{$codeSize$}{12}
    \Let{$maxValue$}{$(1 << codeSize) - 1$}
    \Let{$maxCode$}{$maxValue - 1$}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{LZW compression algorithm.}
  \label{alg:lzw-compression}
  \begin{algorithmic}[1]
    \ForTo{$nextCode$}{$0$}{$tableSize$}
      \Let{$codeValues[nextCode]$}{$-1$}
    \EndFor

    \Let{$nextCode$}{$256$}

    \Let{$stringCode$}{\VoidCall{$ReadByte$}}
    \Let{$charCode$}{\VoidCall{$ReadByte$}}

    \While{\neof}
      \Let{$index$}{\Call{GetHashTableIndex}{$stringCode,charCode$}}

      \If{$codeValues[index] \neq -1$} \Comment{If it's in the table}
        \Let{$stringCode$}{$codeValues[index]$}
      \Else \Comment{If it's not in the table}
        \State \Call{outputCode}{$stringCode$}

        \If{$nextCode \leq maxCode$}

          \Let{$stringTable[index]$}{$(stringCode, charCode)$}

          \Let{$codeValues[index]$}{$nextCode$}
          \Let{$nextCode$}{$nextCode + 1$}

        \EndIf

        \Let{$stringCode$}{$charCode$}

      \EndIf

      \Let{$charCode$}{\VoidCall{$ReadByte$}}

    \EndWhile

    \State \Call{outputCode}{$stringCode$}
    \State \Call{outputCode}{$maxValue$}

  \end{algorithmic}
\end{algorithm}

\section{Decompression algorithm}

\subsection{Description}

Using the compression algorithm LZW we on the string
\texttt{ababcbababaaaaaaa} we end up with the compressed data
\texttt{97 98 256 99 257 260 97 262 263 264}. As you may have noticed
before, in a LZW compressed file the string is not included. Then how
could you possibly decompress the file without such essential
information. It turns out that all the corresponding LZW decompression
algorithm do is

\subsection{Algorithm}


\begin{algorithm}[H]
  \caption{LZW non-working decompression algorithm.}
  \label{alg:lzw-non-working-decompression}
  \begin{algorithmic}[1]
    \Let{$oldCode$}{\VoidCall{$ReadByte$}}
    \State \Call{WriteByte}{$oldCode$}
    \Let{$newCode$}{\VoidCall{$ReadByte$}}
    \While{\neof}

%      \If{\Call{NotInTable}{newCode}}
%      \Else
%      \EndIf

      \Let{$string$}{\Call{translate}{$newCode$}}
      \State \Call{outputString}{$string$}
      \Let{$character$}{$string[0]$}

      \State \Call{$AddToStringTable$}{$oldCode, character$}

      \Let{$oldCode$}{$newCode$}
      \Let{$newCode$}{\VoidCall{$ReadByte$}}
    \EndWhile
  \end{algorithmic}
\end{algorithm}

\section{Efficiency}

AS you may noticed doing LZW compression on small files is a small
gain operation. However, doing this on larger files do actully yield a
significant decrease in file sizes.

\FloatBarrier

\printbibliography[heading=subbibliography]

\end{refsection}
