\begin{comment}
  \bibliography{project.bib}
\end{comment}

\chapter{LZW}
\label{ch:rle}

\begin{refsection}

In this chapter we will discuss the data compression algorithm \lzw\index{LZW} as
it is described in
\cite{nelson89:_lzw_data_compr,Welch:1984:THD:1319729.1320134,Salomon:2004:DCC}

\section{Compression algorithm}

\subsection{Description}
\label{sec:lzw-desc}

The \lzw compression\index{\lzw compression} algorithm is best
understood by walking through the LZW algorithms process of
compressing some sample data. Let's we want to compress the string
\texttt{ababcbababaaaaaaa}.

First we will fill a string table\index{string table} containing all
the numbers possible in byte, from 0 to 255, and their corresponding
letters as is shown in table \ref{tab:str-tab-ascii}. We will from now
on refer to these numbers as number codes\index{number code}, or
simply codes\index{code}.

\newcommand{\dotsrow}{\dots & \dots \\}
\newcommand{\strrow}[2]{$#1$ & #2 \\}

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    String & Code \\
    \midrule

    \dotsrow
    \strrow{33}{!}
    \strrow{34}{"}
    \strrow{35}{\#}
    \dotsrow
    \strrow{97}{a}
    \strrow{98}{b}
    \strrow{99}{c}
    \dotsrow
    \strrow{255}{}

    \bottomrule
  \end{tabular}
  \caption{The initial LZW string table}
  \label{tab:str-tab-ascii}
\end{table}

Now let's go through the sample string. First we read the first
character \texttt{a}. If we look up this letter in the table we get
the number code $97$, so we just output this code. Next, we read in
the character \texttt{b}, which has the number $98$. We first output
the code of b, $98$, and then we append the two up until now read
characters together, and get the string \texttt{ab}. After this we
check if this string exists in the string table. If we inspect table
\ref{tab:str-tab-ascii}, we soon realize that the string is
\textit{not} in the table. So the string is added to the table and it
is assigned to the next available code, $256$.

\texttt{a} is discarded, we keep \texttt{b} and we read in another
\texttt{a}. First we output \texttt{b}, but however this time, we end with the appended string
\texttt{ba}. This string doesn't either exist in the table and so we
add it with the code $257$. We throw away \texttt{b}, output
\texttt{a} and read in another \texttt{b}. Now something very
interesting thing happens; The appended string we end up with is this
time \texttt{ab}. But wait a minute, haven't we already added that
string to the string table? Yes, we have, so instead of re-adding that
string to table, we output its code, $256$. This means we instead
separately adding the codes of \texttt{a} and \texttt{b}, we just
output one single code! In the next step the algorithm, we will
let the appended string \texttt{ab} represent the former character.

So we output the single code for \texttt{ab}.  And then we read in the
character \texttt{c}. The string \texttt{abc} doesn't exist in the
table, so we give it the code $258$ and it just keeps going like
this. Table \ref{tab:str-tab-str} shows the codes that were added during the compression
of the string. Table \ref{tab:lzw-walkthru} gives a detailed walkthrough of the compression
of the string, do study this table carefully and don't go on reading
until you fully understand it.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    String & Code \\
    \midrule

    \dotsrow
    \strrow{256}{ab}
    \strrow{257}{ba}
    \strrow{258}{abc}
    \strrow{259}{cb}
    \strrow{260}{bab}
    \strrow{261}{baba}
    \strrow{262}{aa}
    \strrow{263}{aaa}
    \strrow{264}{aaaa}
    \bottomrule
  \end{tabular}
  \caption{The string table after the \lzw algorithm has been run.}
  \label{tab:str-tab-str}
\end{table}

\begin{table}
  \centering
  \newcommand{\lzwrow}[4]{#1 & #2 & #3 & #4 \\}
  \begin{tabular}{llll}
    \toprule
    String Code & New Code & Output Code & New table entry \\
    \midrule

    \lzwrow{a}{b}{a = 97}{ab = 256}
    \lzwrow{b}{a}{b = 98}{ba = 257}
    \lzwrow{a}{b}{}{}
    \lzwrow{ab}{c}{ab = 256}{abc = 258}
    \lzwrow{c}{b}{c = 99}{cb = 259}
    \lzwrow{b}{a}{}{}
    \lzwrow{ba}{b}{ba = 257}{bab = 260}
    \lzwrow{b}{a}{}{}
    \lzwrow{ba}{b}{}{}
    \lzwrow{bab}{a}{bab = 260}{baba = 260}
    \lzwrow{a}{a}{a = 97}{aa = 261}
    \lzwrow{a}{a}{}{}
    \lzwrow{aa}{a}{aa = 262}{aaa = 262}
    \lzwrow{a}{a}{}{}
    \lzwrow{aa}{a}{}{}
    \lzwrow{aaa}{a}{aaa = 263}{aaaa = 263}

    \bottomrule
  \end{tabular}
  \caption{LZW control flow.}
  \label{tab:lzw-walkthru}
\end{table}

\subsection{Algorithm}

In algorithm \ref{alg:lzw-compression} the complete LZW compression
algorithm is presented. Try reading thourhg through it once, but I'd
doubt you'd be able to understand all of it at this. We are going to
have discuss several more concepts before you can understand it.

\begin{algorithm}[H]
  \caption{Settings the constants for the LZW algorithm}
  \label{alg:lzw-constants}
  \begin{algorithmic}[1]
    \Let{$codeSize$}{12}
    \Let{$maxValue$}{$(1 << codeSize) - 1$}
    \Let{$maxCode$}{$maxValue - 1$}
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{The LZW compression algorithm.}
  \label{alg:lzw-compression}
  \begin{algorithmic}[1]
    \ForTo{$nextCode$}{$0$}{$tableSize$}
      \Let{$codeValues[nextCode]$}{$-1$}
    \EndFor

    \Let{$nextCode$}{$256$}

    \Let{$stringCode$}{\VoidCall{$ReadByte$}}
    \Let{$charCode$}{\VoidCall{$ReadByte$}}

    \While{\neof}
      \Let{$index$}{\Call{GetHashTableIndex}{$stringCode,charCode$}}

      \If{$codeValues[index] \neq -1$} \Comment{If it's in the table}
        \Let{$stringCode$}{$codeValues[index]$}
      \Else \Comment{If it's not in the table}
        \State \Call{outputCode}{$stringCode$}

        \If{$nextCode \leq maxCode$}

          \Let{$stringTable[index]$}{$(stringCode, charCode)$}

          \Let{$codeValues[index]$}{$nextCode$}
          \Let{$nextCode$}{$nextCode + 1$}

        \EndIf

        \Let{$stringCode$}{$charCode$}

      \EndIf

      \Let{$charCode$}{\VoidCall{$ReadByte$}}

    \EndWhile

    \State \Call{outputCode}{$stringCode$}
    \State \Call{outputCode}{$maxValue$}

  \end{algorithmic}
\end{algorithm}

\subsubsection{Codes sizes}

All a \lzw compressed file will consist of after this algorithm has
been run, is a long sequence of outputted number codes.

Since all the of the actual strings in the string table have codes
values over $255$, bytes will obviously not be sufficient to store
these codes in a file. You may think we instead use 16-bit numbers to
store the codes, but then you will probably be surprised to know that
traditionally code sizes\index{code size} are in the ranges $9 <
codeSize < 15$. But among all code sizes 12-bit codes are probably the
most frequent ones.

Since most of all file writing funcitons of a language standard
library do not really suppot writing numbers that are not a multiple
of 8, we will also need to figure out of how write number whose sizes
are in the ranges $9 < x < 15$.

\subsubsection{String storage}

\newcommand{\strpair}[2]{(#1,#2)}

You could of course just store all the strings in the string table as
real string data types. However, these strings are going to end up
taking way more space than they really need to.

As you probably remember from section \ref{sec:lzw-desc}, the adde
strings to the table is just the concatenation of the currnently read
in character and the former string. The concatenation of the
characters characters \texttt{a} and \texttt{b} could be expressed as
the string \texttt{ab}. But however, the could also be described by
the pair\index{pair} \strpair{97}{98}, which consists of the two codes
of the two  characters. Okay, there is no real big
difference in size yet, but now consider \texttt{abcbde} and
\texttt{a} and their concatenation \texttt{abcbdea}. If
\texttt{abcbde} has the code, say,  289, then surely the pair
\strpair{289}{97} is much more storage efficent than \texttt{abcbdea}?
Yes, it is of course! You may think we are just nit picking here, but
also need to consider that with huge files this string could end up
becoming very big. And besides, pair of numbers are often easier much easier to deal
with than strings, espically in languages like \C! So there's end much
smaller chance of making sily  mistakes and creating bugs that could
have been avoided if you hade selected the string storage model more
wisely.

Using this new string storage model table \ref{tab:str-tab-str} ends up becoming this
table \ref{tab:str-tab-pair}. You may notice that we end creating this
beautiful recursive structure using this model. We will find out more
about this later when are going to decompress the data.

\newcommand{\pairrow}[3]{$#1$ & \strpair{#2}{#3} \\}

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    String & Code \\
    \midrule
    \dotsrow
    \pairrow{256}{97}{b}
    \pairrow{257}{98}{a}
    \pairrow{258}{256}{c}
    \pairrow{259}{99}{b}
    \pairrow{260}{257}{b}
    \pairrow{261}{260}{a}
    \pairrow{262}{87}{a}
    \pairrow{263}{262}{a}
    \pairrow{264}{263}{a}
    \bottomrule
  \end{tabular}
  \caption{The string table after the \lzw algorithm has been run.}
  \label{tab:str-tab-pair}
\end{table}

\subsubsection{Table size}

And we can't just of course add strings to the string table willy
nilly. For very large files this table may grow extremely large and
the compression program would end of being a hog on the computers
resources.

\subsubsection{Finding the correct codes}

Hashing bla bla.

\section{Decompression algorithm}

\subsection{Description}

Using the compression algorithm LZW we on the string
\texttt{ababcbababaaaaaaa} we end up with the compressed data
\texttt{97 98 256 99 257 260 97 262 263 264}. As you may have noticed
before, in a LZW compressed file the string is not included. Then how
could you possibly decompress the file without such essential
information. It turns out that all the corresponding LZW decompression
algorithm do is

\subsection{Algorithm}


\begin{algorithm}[H]
  \caption{LZW non-working decompression algorithm.}
  \label{alg:lzw-non-working-decompression}
  \begin{algorithmic}[1]
    \Let{$oldCode$}{\VoidCall{$ReadByte$}}
    \State \Call{WriteByte}{$oldCode$}
    \Let{$newCode$}{\VoidCall{$ReadByte$}}
    \While{\neof}

%      \If{\Call{NotInTable}{newCode}}
%      \Else
%      \EndIf

      \Let{$string$}{\Call{translate}{$newCode$}}
      \State \Call{outputString}{$string$}
      \Let{$character$}{$string[0]$}

      \State \Call{$AddToStringTable$}{$oldCode, character$}

      \Let{$oldCode$}{$newCode$}
      \Let{$newCode$}{\VoidCall{$ReadByte$}}
    \EndWhile
  \end{algorithmic}
\end{algorithm}

\section{Efficiency}

AS you may noticed doing LZW compression on small files is a small
gain operation. However, doing this on larger files do actully yield a
significant decrease in file sizes.

\FloatBarrier

\printbibliography[heading=subbibliography]

\end{refsection}
