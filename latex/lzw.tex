\begin{comment}
  \bibliography{project.bib}
\end{comment}

\chapter{LZW}
\label{ch:rle}

\begin{refsection}

In this chapter we will discuss the data compression algorithm \lzw\index{LZW} as
it is described in
\cite{nelson89:_lzw_data_compr,Welch:1984:THD:1319729.1320134,Salomon:2004:DCC}

\section{Compression algorithm}

\subsection{Description}
\label{sec:lzw-desc}

The \lzw compression\index{\lzw compression} algorithm is best
understood by walking through the LZW algorithms process of
compressing some sample data. Let's we want to compress the string
\texttt{ababcbababaaaaaaa}.

First we will fill a string table\index{string table} containing all
the numbers possible in byte, from 0 to 255, and their corresponding
letters as is shown in table \ref{tab:str-tab-ascii}. We will from now
on refer to these numbers as number codes\index{number code}, or
simply codes\index{code}.

\newcommand{\dotsrow}{\dots & \dots \\}
\newcommand{\strrow}[2]{$#1$ & #2 \\}

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    String & Code \\
    \midrule

    \dotsrow
    \strrow{33}{!}
    \strrow{34}{"}
    \strrow{35}{\#}
    \dotsrow
    \strrow{97}{a}
    \strrow{98}{b}
    \strrow{99}{c}
    \dotsrow
    \strrow{255}{}

    \bottomrule
  \end{tabular}
  \caption{The initial LZW string table}
  \label{tab:str-tab-ascii}
\end{table}

Now let's go through the sample string. First we read the first
character \texttt{a}. If we look up this letter in the table we get
the number code $97$, so we just output this code. Next, we read in
the character \texttt{b}, which has the number $98$. We first output
the code of b, $98$, and then we append the two up until now read
characters together, and get the string \texttt{ab}. After this we
check if this string exists in the string table. If we inspect table
\ref{tab:str-tab-ascii}, we soon realize that the string is
\textit{not} in the table. So the string is added to the table and it
is assigned to the next available code, $256$.

\texttt{a} is discarded, we keep \texttt{b} and we read in another
\texttt{a}. First we output \texttt{b}, but however this time, we end with the appended string
\texttt{ba}. This string doesn't either exist in the table and so we
add it with the code $257$. We throw away \texttt{b}, output
\texttt{a} and read in another \texttt{b}. Now something very
interesting thing happens; The appended string we end up with is this
time \texttt{ab}. But wait a minute, haven't we already added that
string to the string table? Yes, we have, so instead of re-adding that
string to table, we output its code, $256$. This means we instead
separately adding the codes of \texttt{a} and \texttt{b}, we just
output one single code! In the next step the algorithm, we will
let the appended string \texttt{ab} represent the former character.

So we output the single code for \texttt{ab}.  And then we read in the
character \texttt{c}. The string \texttt{abc} doesn't exist in the
table, so we give it the code $258$ and it just keeps going like
this. Table \ref{tab:str-tab-str} shows the codes that were added during the compression
of the string. Table \ref{tab:lzw-walkthru} gives a detailed walkthrough of the compression
of the string, do study this table carefully and don't go on reading
until you fully understand it.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    String & Code \\
    \midrule

    \dotsrow
    \strrow{256}{ab}
    \strrow{257}{ba}
    \strrow{258}{abc}
    \strrow{259}{cb}
    \strrow{260}{bab}
    \strrow{261}{baba}
    \strrow{262}{aa}
    \strrow{263}{aaa}
    \strrow{264}{aaaa}
    \bottomrule
  \end{tabular}
  \caption{The string table after the \lzw algorithm has been run.}
  \label{tab:str-tab-str}
\end{table}

\begin{table}
  \centering
  \newcommand{\lzwrow}[4]{#1 & #2 & #3 & #4 \\}
  \begin{tabular}{llll}
    \toprule
    String Code & New Code & Output Code & New table entry \\
    \midrule

    \lzwrow{a}{b}{a = 97}{ab = 256}
    \lzwrow{b}{a}{b = 98}{ba = 257}
    \lzwrow{a}{b}{}{}
    \lzwrow{ab}{c}{ab = 256}{abc = 258}
    \lzwrow{c}{b}{c = 99}{cb = 259}
    \lzwrow{b}{a}{}{}
    \lzwrow{ba}{b}{ba = 257}{bab = 260}
    \lzwrow{b}{a}{}{}
    \lzwrow{ba}{b}{}{}
    \lzwrow{bab}{a}{bab = 260}{baba = 260}
    \lzwrow{a}{a}{a = 97}{aa = 261}
    \lzwrow{a}{a}{}{}
    \lzwrow{aa}{a}{aa = 262}{aaa = 262}
    \lzwrow{a}{a}{}{}
    \lzwrow{aa}{a}{}{}
    \lzwrow{aaa}{a}{aaa = 263}{aaaa = 263}

    \bottomrule
  \end{tabular}
  \caption{LZW control flow.}
  \label{tab:lzw-walkthru}
\end{table}

\subsection{Algorithm}

In algorithm \ref{alg:lzw-compression} the complete LZW compression
algorithm is presented. Try reading through it at least once,
but I doubt you'd be able to understand all of it at this point. The
implementation of the aglorithm turns out not be as easy as it
sounds.

\begin{algorithm}[H]
  \caption{The LZW compression algorithm.}
  \label{alg:lzw-compression}
  \begin{algorithmic}[1]
    \Let{$nextCode$}{$256$}
    \Let{$stringCode$}{\VoidCall{$ReadByte$}}
    \Let{$charCode$}{\VoidCall{$ReadByte$}}

    \While{\neof}

      \If{\Call{InStringTable}{$stringCode,charCode$}} \label{algl:hasingcheckintable}
        \Let{$stringCode$}{\Call{GetCode}{$stringCode,charCode$}} \label{algl:hasgetcode}
      \Else
        \State \Call{outputCode}{$stringCode$}

        \If{$nextCode \leq maxCode$}

          \State \Call{AddToStringTable}{$nextCode, stringCode, charCode$}\label{algl:hashadd}
          \Let{$nextCode$}{$nextCode + 1$}

        \EndIf

        \Let{$stringCode$}{$charCode$}

      \EndIf

      \Let{$charCode$}{\VoidCall{$ReadByte$}}

    \EndWhile

    \State \Call{outputCode}{$stringCode$}
    \State \Call{outputCode}{$maxValue$}

  \end{algorithmic}
\end{algorithm}

\subsubsection{Codes sizes}

All a \lzw compressed file will consist of after this algorithm has
been run, is a long sequence of outputted number codes.

Since all the of the actual strings in the string table have codes
values over $255$, bytes will obviously not be sufficient to store
these codes in a file. You may think we instead use 16-bit numbers to
store the codes, but then you will probably be surprised to know that
traditionally code sizes\index{code size} are in the ranges $9 <
codeSize < 15$. But among all code sizes 12-bit codes are probably the
most frequent ones.

Since most of all file writing funcitons of a language standard
library do not really suppot writing numbers that are not a multiple
of 8, we will also need to figure out of how write number whose sizes
are in the ranges $9 < x < 15$.

\subsubsection{String storage}

\newcommand{\strpair}[2]{(#1,#2)}

You could of course just store all the strings in the string table as
real string data types. However, these strings are going to end up
taking way more space than they really need to.

As you probably remember from section \ref{sec:lzw-desc}, the added
strings to the table is just the concatenation of the currnently read
in character and the former string. The concatenation of the
characters characters \texttt{a} and \texttt{b} could be expressed as
the string \texttt{ab}. But however, they could also be described by
the pair\index{pair} \strpair{97}{98}, which consists of the two codes
of the two  characters. Okay, there is no real big
difference in size yet, but now consider \texttt{abcbde} and
\texttt{a} and their concatenation \texttt{abcbdea}. If
\texttt{abcbde} has the code, say,  289, then surely the pair
\strpair{289}{97} is much more storage efficent than \texttt{abcbdea}?
Yes, it is of course! You may think we are just nit picking here, but
also need to consider that with huge files this string could end up
becoming very big. And besides, pair of numbers are often easier much easier to deal
with than strings, espically in languages like \C! So there's end much
smaller chance of making sily  mistakes and creating bugs that could
have been avoided if you hade selected the string storage model more
wisely.

Using this new string storage model table \ref{tab:str-tab-str} ends up becoming this
table \ref{tab:str-tab-pair}. You may notice that we end creating this
beautiful recursive structure using this model. We will find out more
about this later when are going to decompress the data.

\newcommand{\pairrow}[3]{$#1$ & \strpair{#2}{#3} \\}

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    String & Code \\
    \midrule
    \dotsrow
    \pairrow{256}{97}{b}
    \pairrow{257}{98}{a}
    \pairrow{258}{256}{c}
    \pairrow{259}{99}{b}
    \pairrow{260}{257}{b}
    \pairrow{261}{260}{a}
    \pairrow{262}{87}{a}
    \pairrow{263}{262}{a}
    \pairrow{264}{263}{a}
    \bottomrule
  \end{tabular}
  \caption{The string table after the \lzw algorithm has been run.}
  \label{tab:str-tab-pair}
\end{table}

\subsubsection{Table size}

And we can't just add strings to the string table willy
nilly. For very large files this table may grow unacceptably large and
the compression program would end of being a hog on the computers
resources. And besides, since we are using fixed code sizes there is
limit on how large the string table can grow. For example, for 11-bit
codes the maximum size of the string table will be $2^{11}=2048$. In
algorithm \ref{alg:lzw-constants} we show how set the size constants
for the example code size 12. Notice the maximum value of the final
code, $maxCode$ is one less than the actual max size of the
table. That's becuase at the end of algorithm
\ref{alg:lzw-compression} we output the final code to always be the
maximum value of the current code size type. You will see why we do
this when discuss the decompression algorithm, but for now ignore it.

\begin{algorithm}[H]
  \caption{Settings the constants for the LZW algorithm for the
    example code size 12.}
  \label{alg:lzw-constants}
  \begin{algorithmic}[1]
    \Let{$codeSize$}{12}
    \Let{$maxValue$}{$(1 << codeSize) - 1$}
    \Let{$maxCode$}{$maxValue - 1$}
  \end{algorithmic}
\end{algorithm}

\subsubsection{Finding the correct codes}

When checking if a string is in the string
table \algref{alg:lzw-compression}{algl:hasingcheckintable} and when
we in line \algref{alg:lzw-compression}{algl:hasgetcode} get the code
of string, the functions \textproc{InStringTable} and
\textproc{GetCode} will have to some way or another search the hash
table for the corresponding code. One way to implement these two
funcitons would be two use the code as an index to an array of
strings. But this clearly prohobihivetely slow as you would have
search the entire string table, string by string, when you would want
the code of a string.

The easiest way to solve this problem is to just use a hash table. The
string can used to create a key to index the table get the needed
codes.

Since most modern languages already include some sort of hash table in
their standard library, this should be very hard to implement. If you
are using bit more lower level language like \C, you will either have
to roll your own or use a library. In the sample \C source code of
this a simple hash table is used to gain much efficeny.

But this solutions is of course not perfect.

\section{Decompression algorithm}

\subsection{Description}

Using the compression algorithm LZW we on the string
\texttt{ababcbababaaaaaaa} we end up with the compressed data
\texttt{97 98 256 99 257 260 97 262 263 264}. As you may have noticed
before, in a LZW compressed file the string is not included. Then how
could you possibly decompress the file without such essential
information. It turns out that all the corresponding LZW decompression
algorithm do is

\subsection{Algorithm}

\begin{algorithm}[H]
  \caption{LZW non-working decompression algorithm.}
  \label{alg:lzw-non-working-decompression}
  \begin{algorithmic}[1]
    \Let{$oldCode$}{\VoidCall{$ReadByte$}}
    \State \Call{WriteByte}{$oldCode$}
    \Let{$newCode$}{\VoidCall{$ReadByte$}}
    \While{\neof}

%      \If{\Call{NotInTable}{newCode}}
%      \Else
%      \EndIf

      \Let{$string$}{\Call{translate}{$newCode$}}
      \State \Call{outputString}{$string$}
      \Let{$character$}{$string[0]$}

      \State \Call{$AddToStringTable$}{$oldCode, character$}

      \Let{$oldCode$}{$newCode$}
      \Let{$newCode$}{\VoidCall{$ReadByte$}}
    \EndWhile
  \end{algorithmic}
\end{algorithm}

\section{Efficiency}

AS you may noticed doing LZW compression on small files is a small
gain operation. However, doing this on larger files do actully yield a
significant decrease in file sizes.

\FloatBarrier

\printbibliography[heading=subbibliography]

\end{refsection}
