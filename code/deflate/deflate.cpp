#include <cstdlib>
#include <cctype>
#include <cstdio>
#include <cstdlib>

/*

  The encoder can generate the tables in any way. The idea is that a
sophisticated Deflate encoder may collect statistics as it inputs the
data and compresses blocks

*/


/*

  1. Encode the teh data and match for strings using LZ77.

  2. If the data is short use the fixed codes. Else use huffman encoding on the codes to generate shorter ones.

  3. Using the selected encode the codes generated by LZ77.

  */

#include "../io.h"
#include "../bits.h"
#include "deflate.h"
#include "../data_stream.h"

using std::vector;

#define HUFFMAN_CODES 288
#define DISTANCE_CODES 30
#define LENGTH_CODES 29

typedef struct{
    BYTE BFINAL; /* Is this the last data block? */
    BYTE BTYPE; /* Data compression type. */
} DEFLATE_BlockHeader;

typedef struct{
    /* the code value of the code*/
    unsigned short codeValue;
    unsigned short litteralValue;

    /* maxvalue: 256 */
    /* The codes whose lengths are zero are ignored.  */
    size_t codeLength;
} HuffmanCode;

typedef std::vector<HuffmanCode> CodesList;

typedef struct{
    unsigned short extraBits;
    unsigned short minDist;
} DistanceTableEntry;

typedef struct{
    unsigned short extraBits;
    unsigned short minLength;
} LengthTableEntry;

typedef struct {
    unsigned short HLIT; /* 5 bits. number of literal/length codes - 257(257-286).   */
    unsigned short HDIST; /* 5 bits. Number of distance codes - 1 (1 - 32)  */
    unsigned short HCLEN; /* 4 bits. Number of code length codes - 4 (4 - 19) */
} DEFLATE_DynamicBlockHeader;

CodesList loadCodeLengthCodes(unsigned short HCLEN,BitReader & compressedStream);

CodesList loadDistanceCodes(unsigned short HDIST,
    CodesList codeLengthCodes,
    BitReader & compressedStream);

void repeatZeroLengthCode(
    BYTE * codeLengths,
    int * i,
    int minCodeLength,
    int extraBits,
    BitReader & compressedStream);

CodesList loadLiteralLengthCodes(
    unsigned short HLIT,
    CodesList codeLengthCodes,
    BitReader & compressedStream);

CodesList loadUsingCodeLengthCodes(
    unsigned short length,
    unsigned short alphabetLength,
    CodesList codeLengthCodes,
    BitReader & compressedStream);

#define CODE_LENGTH_CODES 19

CodesList translateCodes(BYTE * codeLengths, int alphabetSize);

int * getCodeLengthFreqs(BYTE * codeLengths, int alphabetSize);

void loadDynamicTables(
    CodesList * huffmanCodes,
    CodesList * distanceCodes,
    BitReader & compressedStream);

DEFLATE_DynamicBlockHeader loadDEFLATE_DynamicBlockHeader(BitReader & compressedStream);

void printDEFLATE_DynamicBlockHeader(DEFLATE_DynamicBlockHeader blockHeader);

#define DATA_STREAM_GROW_FACTOR 2


void setFixedHuffmanCodes(void);
void setFixedDistanceCodes(void);

void printDEFLATE_BlockHeader(DEFLATE_BlockHeader header);

HuffmanCode readCode(const CodesList & codes,  BitReader & stream);

unsigned short appendBit(unsigned short codeValue, BitReader & stream);

#define BTYPE_NO_COMPRESSION 0
#define BTYPE_COMPRESSED_FIXED_HUFFMAN_CODES 1
#define BTYPE_COMPRESSED_DYNAMIC_HUFFMAN_CODES 2
#define BTYPE_RESERVED 3

#define END_OF_BLOCK 256
#define LITTERAL_VALUES_MAX 255
#define DISTANCE_MIN 257
#define DISTANCE_MAX 285

unsigned short readRestOfLengthCode(
    unsigned short code,
    BitReader & compressedStream);

unsigned short readRestOfDistanceCode(unsigned short code,BitReader & compressedStream);

void printCode(HuffmanCode code);
int getBitToggled(unsigned short value,int bit);

int getMinimumCodeLength(const CodesList & codes);

/* return the index of the code with the value, and return -1 if
   it can't be found. */

/* PERFORMANCE BOTTLENECK*/
int findCode(const CodesList & codes,unsigned short codeValue, unsigned short codeLength);

unsigned int inputCodeLSBRev(int codeSize, BitReader & stream);

void readNonCompresedBlock(BitReader & compressedStream, vector<BYTE> & decompressedList);

void readCompresedBlock(
    const CodesList & huffmanCodes,
    const CodesList & distanceCodes,
    BitReader & compressedStream,
    vector<BYTE> & decompressedList);

DEFLATE_BlockHeader readDEFLATE_BlockHeader(BitReader & stream);


void decodeLengthDistancePair(
    HuffmanCode lengthCode,
    const CodesList & distanceCodes,
    BitReader & compressedStream,
    vector<BYTE> & decompressedList);

void outputLengthDistancePair(
    unsigned short lengthCode,
    unsigned short distanceCode,
    vector<BYTE> &  decompressedList);

void printCodesList(const CodesList & codes);

void repeatPreviousLengthCode(
    BYTE * codeLengths,
    int * i,
    BitReader & compressedStream);


/* Globals */

int remainingPacketBits;

CodesList fixedHuffmanCodes;
CodesList fixedDistanceCodes;

LengthTableEntry lengthTable[LENGTH_CODES] = {

    {0,3},
    {0,4},
    {0,5},
    {0,6},
    {0,7},
    {0,8},
    {0,9},
    {0,10},

    {1,11},
    {1,13},
    {1,15},
    {1,17},

    {2,19},
    {2,23},
    {2,27},
    {2,31},

    {3,35},
    {3,43},
    {3,51},
    {3,59},

    {4,67},
    {4,83},
    {4,99},
    {4,115},

    {5,131},
    {5,163},
    {5,195},
    {5,227},

    {0, 258}
};

DistanceTableEntry distanceTable[DISTANCE_CODES] = {
    {0,1},
    {0,2},
    {0,3},
    {0,4},

    {1,5},
    {1,7},

    {2,9},
    {2,13},

    {3,17},
    {3,25},

    {4,33},
    {4,49},

    {5,65},
    {5,97},

    {6,129},
    {6,193},

    {7,257},
    {7,385},

    {8,513},
    {8,769},

    {9,1025},
    {9,1537},

    {10,2049},
    {10,3073},

    {11,4097},
    {11,6145},

    {12,8193},
    {12,12289},

    {13,16385},
    {13,24577},
};

int getMinimumCodeLength(const CodesList & codes)
{
    size_t min;
    size_t i;

    /* find the first non-zero length code */
    for(i = 0; i < codes.size(); ++i){
        if(codes[i].codeLength != 0){
            min = codes[i].codeLength;
            break;
        }
    }

    /* find the minimum length code. */
    for(; i < codes.size(); ++i)
        if(codes[i].codeLength != 0 && codes[i].codeLength < min)
            min = codes[i].codeLength;

    return min;
}

void setFixedHuffmanCodes(void)
{
    int i;
    HuffmanCode code;

    /* Litteral value 256 is the end code.*/

    /* Literal values 0-143 are given the codes
       00110000(=48=0x30) - 10111111(191=0xbf) of length 8*/
    for(i = 0; i <= 143; ++i){
        code.codeValue = 0x30 + i;
        code.litteralValue = i;
        code.codeLength = 8;
        fixedHuffmanCodes.push_back(code);
    }

    /* Literal values 144-255 are given the codes
       1 1001 0000(=400=0x190) - 1 1111 1111(=511=0x1ff) of length 9*/
    for(i = 144; i <= 255; ++i){
        code.codeValue = 0x190 + i - 144;
        code.litteralValue = i;
        code.codeLength = 9;
        fixedHuffmanCodes.push_back(code);

    }

    /* Literal values 256-279 are given the codes
       000 0000(=0=0x0) - 001 0111(=23=0x17) of length 7*/
    for(i = 256; i <= 279; ++i){
        code.codeValue = 0x0 + i - 256;
        code.litteralValue = i;
        code.codeLength = 7;
        fixedHuffmanCodes.push_back(code);

    }

    /* Literal values 280-287 are given the codes
       1100 0000(=192=0xc0) - 1100 0111(=199=0xc7) of length 8*/
    for(i = 280; i <= 287; ++i){
        code.codeValue = 0xc0 + i - 280;
        code.litteralValue = i;
        code.codeLength = 8;
        fixedHuffmanCodes.push_back(code);

    }
}

void setFixedDistanceCodes(void)
{
    int i;
    HuffmanCode code;

    /*
      "Distance codes 0-31 are represented by (fixed-length) 5-bit codes"
    */
    for(i = 0; i <= 31; ++i){
        code.codeValue = i;
        code.litteralValue = i;
        code.codeLength = 5;
	fixedDistanceCodes.push_back(code);
    }
}

void readNonCompresedBlock(BitReader & compressedStream, vector<BYTE> & decompressedList)
{
    BYTE b1;
    BYTE b2;
    unsigned long uncompressedBlockSize;
/* if dynaic codes are used a new table is read in before the decompression
   of the data. */

    compressedStream.nextByte();
    /* FIXME: does this handle big and little endian? */
    /* Implement a routine for doing this. */
    b1 = compressedStream.readBits(8);
    b2 = compressedStream.readBits(8);

    uncompressedBlockSize = (b1 + b2 * 256);

    /* Skip NLEN */
    compressedStream.readBits(8);
    compressedStream.readBits(8);

    for(unsigned long i = 0; i < uncompressedBlockSize; ++i){

	BYTE b = compressedStream.readBits(8);
	decompressedList.push_back(b);
    }
}

vector<BYTE> deflateDecompress(vector<BYTE> data)
{

    printf("lol\n");
    DEFLATE_BlockHeader header;
    vector<BYTE> decompressedList;

    BitReader inBits(data.begin(), LSBF);

/*    translateCodesTest(); */

    /* TODO: ???? correct endianess?  */
/*    compressedStream = getNewDataStream(data, ENDIAN_BIG); */

    /* the first two bytes of the compressed stream were headers bytes, which
       we have already read, so skip them. */
    inBits.readBits(8);
    inBits.readBits(8);

    /* Put this into a preparatory function? */
    setFixedHuffmanCodes();
    setFixedDistanceCodes();

    remainingPacketBits = 8;

    do{
        /* Skip past to the next byte in the stream where the next block begins. */

        header = readDEFLATE_BlockHeader(inBits);
        printDEFLATE_BlockHeader(header);

        if(header.BTYPE == BTYPE_NO_COMPRESSION){

            readNonCompresedBlock(inBits, decompressedList);

        } else{

	    CodesList huffmanCodes;
	    CodesList distanceCodes;

            if (header.BTYPE == BTYPE_COMPRESSED_DYNAMIC_HUFFMAN_CODES) {

                loadDynamicTables(&huffmanCodes, &distanceCodes, inBits);

            } else if(header.BTYPE == BTYPE_COMPRESSED_FIXED_HUFFMAN_CODES) {
                huffmanCodes = fixedHuffmanCodes;
                distanceCodes = fixedDistanceCodes;
            }

            readCompresedBlock(
                huffmanCodes,
                distanceCodes,
                inBits,
                decompressedList);
        }
    }while(header.BFINAL == 0);

    return decompressedList;
}


void loadDynamicTables(
    CodesList * huffmanCodes,
    CodesList * distanceCodes,
    BitReader & compressedStream)
{
    DEFLATE_DynamicBlockHeader blockHeader;

    CodesList codeLengthCodes;

    blockHeader = loadDEFLATE_DynamicBlockHeader(compressedStream);
    printDEFLATE_DynamicBlockHeader(blockHeader);

    codeLengthCodes = loadCodeLengthCodes(blockHeader.HCLEN, compressedStream);

    printCodesList(codeLengthCodes);

    *huffmanCodes = loadLiteralLengthCodes(
        blockHeader.HLIT,
        codeLengthCodes,
        compressedStream);

    printCodesList(*huffmanCodes);

    *distanceCodes = loadDistanceCodes(
        blockHeader.HDIST,
        codeLengthCodes,
        compressedStream);

    printCodesList(*distanceCodes);
}

CodesList loadLiteralLengthCodes(
    unsigned short HLIT,
    CodesList codeLengthCodes,
    BitReader & compressedStream)
{
    return loadUsingCodeLengthCodes(
        HLIT + 257,
        HUFFMAN_CODES,
        codeLengthCodes,
        compressedStream);
}


CodesList loadDistanceCodes(unsigned short HDIST,
    CodesList codeLengthCodes,
    BitReader & compressedStream)
{
    return loadUsingCodeLengthCodes(
        HDIST + 1,
        DISTANCE_CODES,
        codeLengthCodes,
        compressedStream);
}

CodesList loadUsingCodeLengthCodes(
    unsigned short length,
    unsigned short alphabetLength,
    CodesList codeLengthCodes,
    BitReader & compressedStream)
{
    int  i;
    BYTE codeLengths[HUFFMAN_CODES];
    HuffmanCode code;
    int codesLenI;

    codesLenI = 0;

    for(i = 0; i < HUFFMAN_CODES; ++i)
        codeLengths[i] = 0;

    while(1){
        code = readCode(codeLengthCodes, compressedStream);
        printCode(code);

        if(/*code.litteralValue >= 0 &&*/ code.litteralValue <= 15){

            codeLengths[codesLenI++] = code.litteralValue;

        } else if(code.litteralValue == 16){
            repeatPreviousLengthCode(codeLengths, &codesLenI, compressedStream);

        }else if(code.litteralValue == 17){
            repeatZeroLengthCode(codeLengths, &codesLenI, 3, 3, compressedStream);

        } else if(code.litteralValue == 18){
            repeatZeroLengthCode(codeLengths, &codesLenI, 11, 7, compressedStream);
        }

        if(codesLenI == length){
            break;
        }
    }

    return translateCodes(codeLengths, alphabetLength);
}

void repeatPreviousLengthCode(
    BYTE * codeLengths,
    int * i,
    BitReader & compressedStream)
{
    int repeatLength;
    int previousCode;
    int j;

    /* Repeat codes are recursive!!!!

       Example:
       Codes 8, 16 (+2 bits 11),
       16 (+2 bits 10) will expand to
       12 code lengths of 8 (1 + 6 + 5)*/


    repeatLength =  3 + compressedStream.readBits(2);

    previousCode = codeLengths[(*i) - 1];

    for(j = 0; j < repeatLength; ++j){
        codeLengths[*i] = previousCode;
        (*i)++;
    }
}

void repeatZeroLengthCode(
    BYTE * codeLengths,
    int * i,
    int minCodeLength,
    int extraBits,
    BitReader & compressedStream)
{
    int realLength;
    int j;


    realLength =  minCodeLength + compressedStream.readBits(extraBits);

    for(j = 0; j < realLength; ++j){
        codeLengths[*i] = 0;
        (*i)++;
    }
}


CodesList loadCodeLengthCodes(unsigned short HCLEN,BitReader & compressedStream)
{
    unsigned short realLength;
    BYTE codeLengthOrder[CODE_LENGTH_CODES] = {
        16, 17, 18,0, 8, 7,
        9, 6, 10, 5, 11, 4,
        12, 3, 13, 2, 14, 1, 15};

    BYTE codeLengths[CODE_LENGTH_CODES];

    int i;

    realLength = HCLEN + 4;

    for(i = 0; i < CODE_LENGTH_CODES; ++i)
        codeLengths[i] = 0;

    for(i = 0; i < realLength; ++i)
        codeLengths[codeLengthOrder[i]] = compressedStream.readBits(3);

    return translateCodes(codeLengths , CODE_LENGTH_CODES);
}

DEFLATE_DynamicBlockHeader loadDEFLATE_DynamicBlockHeader(BitReader & compressedStream)
{
    DEFLATE_DynamicBlockHeader blockHeader;

    blockHeader.HLIT = compressedStream.readBits(5);
    blockHeader.HDIST = compressedStream.readBits(5);
    blockHeader.HCLEN = compressedStream.readBits(4);

    return blockHeader;
}

void printDEFLATE_DynamicBlockHeader(DEFLATE_DynamicBlockHeader blockHeader)
{
    verbosePrint("DEFLATE Dynamic Block Header\n");

    verbosePrint("HLIT:%d\n", blockHeader.HLIT);
    verbosePrint("HDIST:%d\n", blockHeader.HDIST);
    verbosePrint("HCLEN:%d\n", blockHeader.HCLEN);
}

void readCompresedBlock(
    const CodesList & huffmanCodes,
    const CodesList & distanceCodes,
    BitReader & compressedStream,
    vector<BYTE> & decompressedList)
{
    HuffmanCode code;

    while(1){

        code = readCode(huffmanCodes, compressedStream);

        printCode(code);

        /* If the code is a simple literal value. */
        if(code.litteralValue <= LITTERAL_VALUES_MAX){
            /* */
	    decompressedList.push_back((BYTE)code.litteralValue);
        }
        else if(code.litteralValue == END_OF_BLOCK){
            /* If the code is a end of block code, then stop.*/
            break;
        } else if(code.litteralValue >= DISTANCE_MIN &&
                  code.litteralValue <= DISTANCE_MAX){

            decodeLengthDistancePair(
                code,
                distanceCodes,
                compressedStream,
                decompressedList);
        } else{
            printError("Invalid code found:\n");
            printCode(code);
        }
    }
}

void decodeLengthDistancePair(
    HuffmanCode lengthCode,
    const CodesList & distanceCodes,
    BitReader & compressedStream,
    vector<BYTE> & decompressedList)
{
    unsigned short fullLengthCode;

    unsigned short fullDistanceCode;

    HuffmanCode distanceCode;

    printCode(lengthCode);

    fullLengthCode =  readRestOfLengthCode(
        lengthCode.litteralValue,
        compressedStream);

    /* Read the following distance code. */
    distanceCode = readCode(distanceCodes, compressedStream);

    printCode(distanceCode);

    fullDistanceCode = readRestOfDistanceCode(distanceCode.litteralValue,compressedStream);

    outputLengthDistancePair(fullLengthCode, fullDistanceCode, decompressedList);
}

void outputLengthDistancePair(
    unsigned short lengthCode,
    unsigned short distanceCode,
    vector<BYTE> &  decompressedList)
{
    unsigned short i;
    BYTE toAdd;

    for(i = 0; i < lengthCode; ++i){

        toAdd = decompressedList[decompressedList.size() - distanceCode];

	decompressedList.push_back(toAdd);
    }
}

unsigned short readRestOfDistanceCode(unsigned short code,BitReader & compressedStream)
{
    unsigned short distanceCode;
    DistanceTableEntry entry;

    entry = distanceTable[code];

    if(entry.extraBits != 0){
        distanceCode = entry.minDist + compressedStream.readBits(entry.extraBits);
    } else{
        distanceCode = entry.minDist;
    }

    return distanceCode;
}


unsigned short readRestOfLengthCode(
    unsigned short code,
    BitReader & compressedStream)
{
    unsigned short lengthCode;
    LengthTableEntry entry;

    entry = lengthTable[code - 257];

    if(entry.extraBits != 0){
        lengthCode = entry.minLength + compressedStream.readBits(entry.extraBits);
    } else{
        lengthCode = entry.minLength;
    }

    return lengthCode;
}

HuffmanCode readCode(const CodesList & codes,  BitReader & stream)
{
    int minimumCodeLength;
    unsigned short codeValue;
    int foundIndex;
    unsigned short codeLength;

    /* inefficient.  */
    minimumCodeLength = getMinimumCodeLength(codes);

    /* read code of minimum value. */
    codeLength = minimumCodeLength;
    codeValue = inputCodeLSBRev(minimumCodeLength, stream);

    foundIndex = findCode(codes,codeValue,codeLength);

    while(foundIndex == -1){

        codeValue = appendBit(codeValue,stream);
        codeLength++;

        foundIndex = findCode(codes,codeValue,codeLength);
    }

    return codes[foundIndex];
}


unsigned int inputCodeLSBRev(int codeSize, BitReader & stream)
{
    unsigned short code;
    int i;

    code = 0;

    for(i = 0; i < codeSize; ++i)
        code = appendBit(code,stream);

    return code;
}

unsigned short appendBit(unsigned short codeValue, BitReader & stream)
{
    unsigned short bit;

    bit = stream.readBits(1);

    return bit | (codeValue << 1);
}

int findCode(const CodesList & codes,unsigned short codeValue, unsigned short codeLength)
{
    size_t i;

    for(i = 0; i < codes.size(); ++i)
        if(codes[i].codeLength != 0)
            if(
                codes[i].codeValue == codeValue &&
                codes[i].codeLength == codeLength)
                break;

    if(i == codes.size()){
        return -1;
    } else{
        return i;
    }
}

DEFLATE_BlockHeader readDEFLATE_BlockHeader(BitReader & stream)
{
    DEFLATE_BlockHeader header;

    header.BFINAL = stream.readBits(1);
    header.BTYPE = stream.readBits(2);

    return header;
}

void printDEFLATE_BlockHeader(DEFLATE_BlockHeader header)
{
    verbosePrint("DEFLATE Header Block\n");
    verbosePrint("BFINAL:%d\n",header.BFINAL);

    verbosePrint("BTYPE(Block Type): %d(",header.BTYPE);

    switch(header.BTYPE){
    case BTYPE_NO_COMPRESSION:
        verbosePrint("No Compression");
        break;
    case BTYPE_COMPRESSED_FIXED_HUFFMAN_CODES:
        verbosePrint("Compressed with fixed Huffman codes");
        break;
    case  BTYPE_COMPRESSED_DYNAMIC_HUFFMAN_CODES:
        verbosePrint("Compressed with dynamic Huffman codes");
        break;
    case BTYPE_RESERVED:
        printError("Reserved(error");
        printf("hai\n");
        exit(0);
        break;
    }
    verbosePrint(")\n");
    verbosePrint("\n");

    verbosePrint("\n");
}

void printCode(HuffmanCode code)
{
    int i;

    if(isprint(code.litteralValue))
        verbosePrint("Code literal value:%d = %c.",code.litteralValue,code.litteralValue);
    else
        verbosePrint("Code literal value:%d.",code.litteralValue);

    if(code.codeLength == 0){
        verbosePrint("zero length code.");
    }else{

        verbosePrint("Code Value:%d = ",code.codeValue);

        for(i = (code.codeLength - 1); i >= 0 ; --i)
            verbosePrint("%d", getBitToggled(code.codeValue,i));
    }
    verbosePrint(".\n");
}

int getBitToggled(unsigned short value,int bit)
{
    return (((value & (1 << bit)) >> bit));
}

CodesList translateCodes(BYTE * codeLengths, int alphabetSize)
{
    int * codeLengthFreqs;
    int * nextCode;
    int i;
    CodesList translatedCodes;

    unsigned short code;
    int maxBits;
    int bits;
    int len;

    printf("code lengths: \n");
    for(i = 0; i < alphabetSize; ++i){
	printf("%d,", codeLengths[i]);
    }

    /* Step 1. */
    codeLengthFreqs = getCodeLengthFreqs(codeLengths, alphabetSize);

    printf("Printing frequency table:\n");
    for(i = 0; i < alphabetSize; ++i)
        if(codeLengthFreqs[i] != 0)
            printf("N:%d | %d\n",i,codeLengthFreqs[i]);

    /* Step 2*/

    /* Find maxBits. Find the highest possible bits length
     whose frequency is not zero. */

    maxBits = 0;

    for(i = 1;i < alphabetSize; ++i)
        if(codeLengthFreqs[i] != 0)
            maxBits = i;

    /* enough memory? */
    nextCode = (int *)malloc(sizeof(int) * (maxBits + 1));

    code = 0;

    codeLengthFreqs[0] = 0;

    for(bits = 1; bits <= maxBits; ++bits){
        code = (code + codeLengthFreqs[bits - 1]) << 1;
	printf("verbcode:%d\n", code);
        nextCode[bits] =  code;
    }

    printf("Printing next code:\n");

    for(i = 1; i <= maxBits; ++i)
        printf("N:%d | %d\n",i,nextCode[i]);

    for(i = 0; i < alphabetSize; ++i){
	HuffmanCode newCode;

	newCode.litteralValue = i;
	newCode.codeLength = 0;

	translatedCodes.push_back(newCode);
    }

    for(i = 0; i < alphabetSize; ++i){

        len = codeLengths[i];

        if(len != 0){
            translatedCodes[i].codeValue = nextCode[len];
            translatedCodes[i].codeLength = len;

            nextCode[len]++;
        }
    }

    free(codeLengthFreqs);
    free(nextCode);

    return translatedCodes;
}

int * getCodeLengthFreqs(BYTE * codeLengths, int alphabetSize)
{
    int * freqs;
    int i;

    freqs = (int *)malloc(sizeof(int) * alphabetSize);

    for(i = 0; i < alphabetSize; ++i)
        freqs[i] = 0;

    for(i = 0; i < alphabetSize; ++i)
	if(codeLengths[i] != 0)
	    ++freqs[codeLengths[i]];

    return freqs;
}

void printCodesList(const CodesList & codes)
{
    size_t i;

    for(i = 0; i < codes.size(); ++i)
        printCode(codes[i]);

}

